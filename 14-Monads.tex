\documentclass[DaoFP]{subfiles}
\begin{document}
    \setcounter{chapter}{13}

    \chapter{Monads（单子）}

    轮子、陶罐和木房子有什么共同点？它们都因为中心的空洞而变得有用。

    老子说：“有之以为利，无之以为用。”

    \hask{Maybe}函子、列表函子和读者函子有什么共同点？它们的中心也都有空洞。

    当单子（monads）在编程背景下被解释时，如果你专注于函子，很难看到共同的模式。要理解单子，你必须深入到函子内部，阅读代码之间的含义。

    \section{Programming with Side Effects（带有副作用的编程）}

    到目前为止，我们一直在讨论的编程主要是基于集合之间的函数（除了非终止的情况）。在编程中，这些函数被称为\emph{全函数}（total）和\emph{纯函数}（pure）。

    全函数对其参数的所有值都有定义。

    纯函数纯粹基于其参数实现，若是闭包函数，纯函数只基于捕获的值——它无法访问外部世界，更不能修改它。

    然而，大多数现实世界的程序都必须与外部世界交互：它们读取和写入文件，处理网络数据包，提示用户输入数据，等等。大多数编程语言通过允许副作用来解决这个问题。副作用是指任何打破函数全性或纯性的行为。

    不幸的是，命令式语言采用的这种“散弹枪”方法使得对程序进行推理变得极其困难。在组合带有副作用的计算时，人们必须小心地逐案推理副作用的组合。更糟糕的是，大多数副作用不仅隐藏在特定函数的实现（而不是接口）中，还隐藏在它所调用的所有函数的实现中，甚至是递归调用的函数中。

    纯函数式语言（如Haskell）采用的解决方案是将副作用编码到纯函数的返回类型中。令人惊讶的是，这对于所有相关的副作用都是可行的。

    这个想法是，用返回类型为\hask{a->b}的计算代替带有副作用的计算，我们使用一个函数\hask{a -> f b}，其中类型构造器\hask{f}编码了适当的副作用。在这一点上，\hask{f}没有任何限制。它甚至不必是一个\hask{Functor}，更不必是一个单子。这将在我们讨论副作用组合时再来详细说明。

    下面是常见副作用及其纯函数版本的列表。

    \subsection{Partiality（部分性）}

    在命令式语言中，部分性通常通过异常来编码。当一个函数使用“错误”的值调用时，它会抛出异常。在某些语言中，异常的类型使用特殊语法编码在函数的签名中。

    在Haskell中，部分计算可以通过返回\hask{Maybe}函子内的结果来实现。当一个函数使用“错误”的参数调用时，它会返回\hask{Nothing}，否则会将结果包装在\hask{Just}构造器中。

    如果我们想要编码更多关于失败类型的信息，可以使用\hask{Either}函子，其中\hask{Left}通常传递错误数据（通常是一个简单的\hask{String}）；而\hask{Right}封装了实际的返回结果，如果有的话。

    调用返回\hask{Maybe}类型的函数的调用者无法轻易忽略异常情况。为了提取值，他们必须对结果进行模式匹配，并决定如何处理\hask{Nothing}。这与某些命令式语言中使用空指针编码错误情况的“穷人版\hask{Maybe}”形成对比。

    \subsection{Logging（记录）}

    有时一个计算必须在某个外部数据结构中记录一些值。记录或审计是一个特别危险的副作用，尤其是在并发程序中，多个线程可能会尝试同时访问同一个日志。

    一个简单的解决方案是让函数返回计算值，并与要记录的项配对。换句话说，将类型为\hask{a -> b}的记录计算替换为纯函数：
    \begin{haskell}
        a -> Writer w b
    \end{haskell}
    其中\hask{Writer}函子是一个薄薄的积的封装：
    \begin{haskell}
        newtype Writer w a = Writer (a, w)
    \end{haskell}
    其中\hask{w}是日志的类型。

    然后由调用者负责提取要记录的值。这是一个常见的技巧：让函数提供所有的数据，让调用者处理副作用。

    \subsection{Environment（环境）}

    有些计算需要只读访问存储在环境中的某些外部数据。只读环境可以简单地作为附加参数传递给函数，而不是由计算秘密访问。如果我们有一个需要访问某些环境\hask{e}的计算\hask{a -> b}，我们将其替换为一个函数\hask{(a, e) -> b}。起初，这似乎不符合在返回类型中编码副作用的模式。然而，这样的函数总是可以柯里化为以下形式：
    \begin{haskell}
        a -> (e -> b)
    \end{haskell}
    该函数的返回类型可以编码在读者函子中，它本身由环境类型\hask{e}参数化：
    \begin{haskell}
        newtype Reader e a = Reader (e -> a)
    \end{haskell}

    这是一个延迟副作用的示例。该函数：
    \begin{haskell}
        a -> Reader e a
    \end{haskell}
    不想处理副作用，因此它将责任委托给调用者。你可以将其视为生成一个稍后执行的脚本。函数\hask{runReader}扮演了这个脚本的一个非常简单的解释器角色：
    \begin{haskell}
        runReader :: Reader e a -> e -> a
        runReader (Reader h) e = h e
    \end{haskell}

    \subsection{State（状态）}

    最常见的副作用与访问和潜在地修改某些共享状态有关。不幸的是，共享状态是并发错误的臭名昭著的根源。这是面向对象语言中的一个严重问题，因为有状态的对象可以透明地在多个客户端之间共享。在Java中，此类对象可以提供单独的互斥锁，但代价是性能下降和死锁的风险。

    在函数式编程中，我们显式地处理状态操作：我们将状态作为附加参数传递，并返回与返回值配对的修改后的状态。我们将一个有状态的计算\hask{a -> b}替换为：
    \begin{haskell}
    (a, s) -> (b, s)
    \end{haskell}
    其中\hask{s}是状态的类型。像以前一样，我们可以将这样的函数柯里化，以将其转换为以下形式：
    \begin{haskell}
        a -> (s -> (b, s))
    \end{haskell}
    该返回类型可以封装在以下函子中：
    \begin{haskell}
        newtype State s a = State (s -> (a, s))
    \end{haskell}
    调用这样的函数的调用者应该通过提供初始状态并调用帮助函数，即解释器\hask{runState}，来检索结果和修改后的状态：
    \begin{haskell}
        runState :: State s a -> s -> (a, s)
        runState (State h) s = h s
    \end{haskell}
    注意，模块化构造器解包，\hask{runState}是完全合法的函数应用。

    \subsection{Nondeterminism（非确定性）}

    想象一下进行量子实验，测量电子的自旋。半数时间自旋向上，半数时间自旋向下。结果是不确定的。一种描述方式是使用多世界解释：当我们进行实验时，宇宙分裂成两个宇宙，每个结果对应一个。

    函数的不确定性意味着它每次调用都会返回不同的结果。我们可以使用多世界解释来模拟这种行为：我们让函数一次返回\emph{所有可能的结果}。实际上，我们会选择一个（可能是无限的）结果列表：

    我们用纯函数替换一个非确定性计算\hask{a -> b}，该函数返回一个充满结果的函子——这次是列表函子：
    \begin{haskell}
        a -> [b]
    \end{haskell}
    同样，调用者决定如何处理这些结果。

    \subsection{Input/Output（输入/输出）}

    这是最棘手的副作用，因为它涉及与外部世界的交互。显然，我们无法在计算机程序中模拟整个世界。因此，为了保持程序的纯粹性，交互必须在程序外部发生。技巧是让程序生成一个脚本。然后将该脚本传递给运行时以执行。运行时是运行程序的有副作用的虚拟机。

    这个脚本本身位于不透明的、预定义的\hask{IO}函子中。程序无法访问此函子中的值：没有\hask{runIO}函数。相反，程序生成的\hask{IO}值在程序结束后执行，至少概念上是如此。

    实际上，由于Haskell的惰性求值，I/O的执行与程序的其余部分交织在一起。构成程序主体的纯函数根据需要进行求值——需求由\hask{IO}脚本的执行驱动。如果不是因为I/O，什么都不会被求值。

    Haskell程序生成的\hask{IO}对象称为\hask{main}，其类型签名为：
    \begin{haskell}
        main :: IO ()
    \end{haskell}
    这是包含单位的\hask{IO}函子——意味着：除了输入/输出脚本之外没有其他有用的值。

    我们很快会讨论如何创建\hask{IO}操作。

    \subsection{Continuation（续延）}

    我们已经看到，作为Yoneda引理的结果，我们可以将类型为\hask{a}的值替换为一个处理该值的函数。该处理器称为续延。调用处理器被视为计算的副作用。在纯函数的上下文中，我们将其编码为：
    \begin{haskell}
        a -> Cont r b
    \end{haskell}
    其中\hask{Cont r}是以下函子：
    \begin{haskell}
        newtype Cont r a = Cont ((a -> r) -> r)
    \end{haskell}
    调用此函数的调用者负责提供续延，即函数\hask{k :: a -> r}，并检索结果：
    \begin{haskell}
        runCont :: Cont r a -> (a -> r) -> r
        runCont (Cont f) k = f k
    \end{haskell}

    这是\hask{Cont r}的\hask{Functor}实例：
    \begin{haskell}
        instance Functor (Cont r) where
        -- f :: a -> b
        -- k :: b -> r
        fmap f c = Cont (\k -> runCont c (k . f))
    \end{haskell}
    请注意，这是一个协变函子，因为类型\hask{a}处于双重否定位置。

    在笛卡尔闭范畴中，续延由自函子生成：
    \[ K_r a = r^{r^a} \]

    \section{Composing Effects（组合副作用）}

    现在我们知道如何使用一个既产生值又产生副作用的函数进行一次巨大飞跃，接下来的问题是弄清楚如何将这个飞跃分解为较小的适合人类的步骤。或者，换句话说，如何将这些较小的步骤组合成一个更大的步骤。

    命令式语言中副作用计算的组合方式是使用常规函数组合来处理值，并让副作用随意组合。

    当我们将带有副作用的计算表示为纯函数时，我们面临的问题是如何组合两个形式为\hask{g :: a -> f b}和\hask{h :: b -> f c}的函数。

    在所有感兴趣的情况下，类型构造器\hask{f}恰好是一个\hask{Functor}，因此在接下来的讨论中我们将假设这一点。

    一种天真的方法是解包第一个函数的结果，将该值传递给下一个函数，然后在旁边组合这两个函数的副作用，并将它们与第二个函数的结果结合起来。即使是我们到目前为止研究的情况，这也不是总能实现的，更不用说对于一个任意的类型构造器。

    为了进行讨论，看看我们如何对\hask{Maybe}函子实现这一点是有启发性的。如果第一个函数返回\hask{Just}，我们通过模式匹配提取内容并将其传递给下一个函数。

    但是，如果第一个函数返回\hask{Nothing}，我们就没有值来调用第二个函数。我们必须短路它，并直接返回\hask{Nothing}。因此，组合是可能的，但这意味着通过根据第一个调用的副作用跳过第二个调用来修改控制流。

    对于某些函子，副作用的组合是可能的，而对于其他函子则不是。我们如何描述这些“好”的函子？

    要使一个函子编码可组合的副作用，我们至少必须能够实现以下多态高阶函数：
    \begin{haskell}
        composeWithEffects :: Functor f =>
        (b -> f c) -> (a -> f b) -> (a -> f c)
    \end{haskell}
    这非常类似于常规函数组合：
    \begin{haskell}
    (.) :: (b -> c) -> (a -> b) -> (a -> c)
    \end{haskell}
    因此自然会问，在什么范畴中，前者定义了箭头的组合。让我们看看构造这样一个范畴还需要什么。

    这个新范畴中的对象与以前一样是Haskell类型。但是箭头$a \twoheadrightarrow b$是由一个Haskell函数实现的：
    \begin{haskell}
        g :: a -> f b
    \end{haskell}
    然后我们可以使用\hask{composeWithEffects}来实现这些箭头的组合。

    为了构造一个范畴，我们要求这个组合是结合的。我们还需要每个对象\hask{a}的恒等箭头。这是箭头$a \twoheadrightarrow a$，因此它对应于一个Haskell函数：
    \begin{haskell}
        idWithEffects :: a -> f a
    \end{haskell}
    它必须相对于\hask{composeWithEffects}的行为像恒等箭头。

    从另一种角度来看，这个箭头允许你向任何类型为\hask{a}的值添加一个琐碎的副作用。这是一个组合在一起时对任何其他副作用都不起作用的副作用。

    我们刚刚定义了一个单子！经过一些重命名和重新排列，我们可以将其写为一个类型类：
    \begin{haskell}
        class Functor m => Monad m where
        (<=<) :: (b -> m c) -> (a -> m b) -> (a -> m c)
        return :: a -> m a
    \end{haskell}
    中缀操作符\hask{<=<}取代了\hask{composeWithEffects}函数。函数\hask{return}是我们新范畴中的恒等箭头。（这不是你会在Haskell的\hask{Prelude}中找到的单子的定义，但正如我们很快会看到的那样，它与之等价。）

    作为练习，让我们定义\hask{Maybe}的\hask{Monad}实例。`鱼`操作符\hask{<=<}将两个函数：
    \begin{haskell}
        f :: a -> Maybe b
        g :: b -> Maybe c
    \end{haskell}
    组合成一个类型为\hask{a -> Maybe c}的函数。这个组合的单位，\hask{return}，将一个值封装在\hask{Just}构造器中。
    \begin{haskell}
        instance Monad Maybe where
        g <=< f = \a -> case f a of
        Nothing -> Nothing
        Just b -> g b
        return = Just
    \end{haskell}

    你可以很容易地说服自己，范畴定律是满足的。特别是\hask{return <=< g}与\hask{g}相同，\hask{f <=< return}与\hask{f}相同。结合律的证明也很简单：如果任何一个函数返回\hask{Nothing}，结果就是\hask{Nothing}；否则，这只是一个简单的函数组合，而函数组合是结合的。

    我们刚刚定义的这个范畴称为\index{Kleisli category}\emph{Kleisli范畴}，适用于单子\hask{m}。函数\hask{a -> m b}称为\index{Kleisli arrow}\emph{Kleisli箭头}。它们使用\hask{<=<}组合，恒等箭头称为\hask{return}。

    前一节中的所有函子都是\hask{Monad}实例。如果你将它们视为类型构造器，甚至函子，很难看到它们之间的相似之处。它们的共同点是它们可以用来实现\emph{可组合}的Kleisli箭头。

    正如老子所说：组合发生在\emph{事物之间}。当我们专注于事物时，我们常常会忽略事物之间的空隙。

    \section{Alternative Definitions（替代定义）}

    使用Kleisli箭头定义单子的优点在于，单子定律只是范畴的结合律和单位律。还有两种等价的单子定义，一种是数学家喜欢的，另一种是程序员喜欢的。

    首先，让我们注意到，在实现鱼操作符时，我们会得到两个函数作为参数。函数唯一有用的地方就是可以应用到一个参数上。当我们应用第一个函数\hask{f :: a -> m b}时，我们得到一个类型为\hask{m b}的值。这时我们可能会陷入困境，但好在\hask{m}是一个函子。函子的特性使我们能够将第二个函数\hask{g :: b -> m c}应用到\hask{m b}上。实际上，\hask{g}的提升由\hask{m}处理，类型为：
    \begin{haskell}
        m b -> m (m c)
    \end{haskell}
    这几乎是我们要找的结果，如果我们能够将\hask{m(m c)}压平为\hask{m c}。这种压平操作称为\hask{join}。换句话说，如果我们得到了：
    \begin{haskell}
        join ::  m (m a) -> m a
    \end{haskell}
    我们就可以实现\hask{<=<}：
    \begin{haskell}
        g <=< f = \a -> join (fmap g (f a))
    \end{haskell}
    or, using point free notation:
    \begin{haskell}
        g <=< f = join . fmap g . f
    \end{haskell}

    反过来，我们也可以通过\hask{<=<}来实现\hask{join}：
    \begin{haskell}
        join = id <=< id
    \end{haskell}
    后者可能不太容易理解，直到你意识到最右边的\hask{id}应用于\hask{m (m a)}，而最左边的\hask{id}应用于\hask{m a}。我们将Haskell函数：
    \begin{haskell}
        m (m a) -> m (m a)
    \end{haskell}
    解释为Kleisli范畴中的箭头$ m (m a) \twoheadrightarrow m a$。类似地，函数：
    \begin{haskell}
        m a -> m a
    \end{haskell}
    实现了Kleisli箭头$m a \twoheadrightarrow a$。它们的Kleisli组合产生了一个Kleisli箭头$m (m a) \twoheadrightarrow a$，即一个Haskell函数：
    \begin{haskell}
        m (m a) -> m a
    \end{haskell}

    这引导我们得出了一个等价的定义，即使用\hask{join}和\hask{return}来定义单子：
    \begin{haskell}
        class Functor m => Monad m where
        join :: m (m a) -> m a
        return :: a -> m a
    \end{haskell}

    这仍然不是你在标准Haskell的\hask{Prelude}中会看到的定义。由于鱼操作符\hask{<=<}是点操作符的推广，使用它相当于无点编程。它让我们在不命名中间值的情况下组合箭头。虽然有些人认为无点编程更优雅，但大多数程序员发现它们难以理解。

    然而，函数组合实际上是分两个步骤进行的：我们应用第一个函数，然后将第二个函数应用于结果。显式地命名中间结果通常有助于理解发生了什么。

    要对Kleisli箭头执行相同操作，我们必须知道如何将第二个Kleisli箭头应用于命名的单子值——第一个Kleisli箭头的结果。执行此操作的函数称为\emph{bind}，并作为一个中缀操作符表示：
    \begin{haskell}
    (>>=) :: m a -> (a -> m b) -> m b
    \end{haskell}
    显然，我们可以用\hask{bind}来实现Kleisli组合：

    \begin{haskell}
        g <=< f = \a -> (f a) >>= g
    \end{haskell}

    反过来，也可以用Kleisli箭头来实现\hask{bind}：
    \begin{haskell}
        ma >>= k = (k <=< id) ma
    \end{haskell}

    这引导我们得出以下定义：
    \begin{haskell}
        class Monad m where
        (>>=) :: m a -> (a -> m b) -> m b
        return :: a -> m a
    \end{haskell}
    这几乎就是你会在\hask{Prelude}中看到的定义，除了一个附加的约束。这个约束声明了每个\hask{Monad}实例也是\hask{Applicative}实例。我们将在讨论单子函子时推迟讨论Applicative。

    我们也可以使用\hask{bind}实现\hask{join}：
    \begin{haskell}
        join  :: (Monad m) => m (m a) -> m a
        join mma =  mma >>= id
    \end{haskell}
    Haskell函数\hask{id}从\hask{m a}到\hask{m a}，或作为一个Kleisli箭头，$m a \twoheadrightarrow a$。

    有趣的是，用\hask{bind}定义的\hask{Monad}自动成为一个函子。它的提升函数称为\hask{liftM}：
    \begin{haskell}
        liftM :: Monad m => (a -> b) -> (m a -> m b)
        liftM f ma = ma >>= (return . f)
    \end{haskell}

    \section{Monad Instances（单子实例）}

    我们现在已经准备好为我们用于副作用的函子定义单子实例了。这将允许我们组合副作用。

    \subsection{Partiality（部分性）}
    我们已经看到通过Kleisli组合实现的\hask{Maybe}单子版本。这里是更常见的使用\hask{bind}的实现：
    \begin{haskell}
        instance Monad Maybe where
        Nothing >>= k = Nothing
        (Just a) >>= k = k a
        return = Just
    \end{haskell}
    将琐碎的副作用添加到任何值意味着将其封装在\hask{Just}中。

    \subsection{Logging（记录）}
    为了组合生成日志的函数，我们需要一种方法来组合单个日志条目。这就是为什么记录器单子：
    \begin{haskell}
        newtype Writer w a = Writer (a, w)
    \end{haskell}
    要求日志的类型是\hask{Monoid}的实例。这允许我们追加日志，并创建一个琐碎的副作用：一个空日志。
    \begin{haskell}
        instance Monoid w => Monad (Writer w) where
        (Writer (a, w)) >>= k = let (Writer (b, w')) = k a
        in Writer (b, mappend w w')
        return a = Writer (a, mempty)
    \end{haskell}
    \index{\hask{let}}\hask{let}子句用于引入局部绑定。在这里，应用\hask{k}的结果进行模式匹配，局部变量\hask{b}和\hask{w'}被初始化。\hask{let}/\hask{in}结构是一个表达式，其值由\hask{in}子句的内容给出。

    \subsection{Environment（环境）}

    读者单子是从环境到返回类型的函数的一个薄封装：
    \begin{haskell}
        newtype Reader e a = Reader (e -> a)
    \end{haskell}
    这里是\hask{Monad}实例：
    \begin{haskell}
        instance Monad (Reader e) where
        ma >>= k = Reader (\e -> let a = runReader ma e
        in runReader (k a) e)
        return a = Reader (\e -> a)
    \end{haskell}
    读取器单子的\hask{bind}的实现创建了一个函数，该函数接受环境作为参数。这个环境被使用两次，第一次是运行\hask{ma}来获取\hask{a}的值，然后用\hask{k a}生成的值进行求值。

    \hask{return}的实现忽略了环境。

    \begin{exercise}
        定义以下数据类型的\hask{Functor}和\hask{Monad}实例：
        \begin{haskell}
            newtype E e a = E (e -> Maybe a)
        \end{haskell}
        提示：你可以使用这个方便的函数：
        \begin{haskell}
            runE :: E e a -> e -> Maybe a
            runE (E f) e = f e
        \end{haskell}
    \end{exercise}

    \subsection{State（状态）}
    像读取器一样，状态单子也是一个函数类型：
    \begin{haskell}
        newtype State s a = State (s -> (a, s))
    \end{haskell}
    它的\hask{bind}类似，除了\hask{k}作用于\hask{a}的结果必须用修改后的状态\hask{s'}运行。
    \begin{haskell}
        instance Monad (State s) where
        st >>= k = State (\s -> let (a, s') = runState st s
        in runState (k a) s')

        return a = State (\s -> (a, s))
    \end{haskell}

    将\hask{bind}应用于恒等式给出了\hask{join}的定义：
    \begin{haskell}
        join :: State s (State s a) -> State s a
        join mma = State (\s -> let (ma, s') = runState mma s
        in runState ma s')
    \end{haskell}
    注意，我们本质上是将第一个\hask{runState}的结果传递给第二个\hask{runState}，只是我们必须解构第二个以便它可以接受一个对偶：
    \begin{haskell}
        join mma = State (\s -> (uncurry runState) (runState mma s))
    \end{haskell}
    在这种形式下，它很容易转换为无点记法：
    \begin{haskell}
        join mma = State (uncurry runState . runState mma)
    \end{haskell}

    有两个基本的Kleisli箭头（第一个，概念上，来自终端对象\hask{()}），我们可以用它们构造任意的有状态计算。第一个检索当前状态：
    \begin{haskell}
        get :: State s s
        get = State (\s -> (s, s))
    \end{haskell}
    第二个修改它：
    \begin{haskell}
        set :: s -> State s ()
        set s = State (\_ -> ((), s))
    \end{haskell}
    许多单子带有它们自己的预定义的基本Kleisli箭头库。

    \subsection{Nondeterminism（非确定性）}

    对于列表单子，让我们考虑如何实现\hask{join}。它必须将一个列表的列表转换为单个列表。这可以通过使用库函数\hask{concat}连接所有内部列表来完成。从那里，我们可以推导出\hask{bind}的实现。
    \begin{haskell}
        instance Monad [] where
        as >>= k = concat (fmap k as)
        return a = [a]
    \end{haskell}
    在这里，\hask{return}构造了一个单例列表。因此，非确定性的琐碎版本就是确定性。

    命令式语言中使用嵌套循环做的事情，我们可以在Haskell中使用列表单子来做。将\hask{as}看作是绑定内循环运行的结果，并将\hask{k}视为外循环中运行的代码。

    在许多方面，Haskell的列表更像是在命令式语言中称为\index{iterator}\emph{迭代器}或\emph{生成器}的东西。由于惰性求值，列表的元素很少同时存储在内存中，因此你可以将Haskell列表概念化为一个指向头部的指针和一个推进到尾部的配方。或者你可以将列表看作是一个协程，它按需生成序列的元素。

    \subsection{Continuation（续延）}

    续延单子的\hask{bind}实现：

    \begin{haskell}
        newtype Cont r a = Cont ((a -> r) -> r)
    \end{haskell}
    需要一些逆向思维，因为控制的固有反转——“不要打电话给我们，我们会打电话给你”的原则。

    \hask{bind}的结果类型为\hask{Cont r b}。为了构造它，我们需要一个函数，该函数接受\hask{k :: b -> r}作为参数：
    \begin{haskell}
        ma >>= fk = Cont (\k -> ...)
    \end{haskell}
    我们有两个可供使用的成分：
    \begin{haskell}
        ma :: Cont r a
        fk :: a -> Cont r b
    \end{haskell}
    我们希望运行\hask{ma}，为此我们需要一个接受\hask{a}的续延。
    \begin{haskell}
        runCont ma (\a -> ...)
    \end{haskell}
    一旦我们有了\hask{a}，我们就可以执行我们的\hask{fk}。结果类型为\hask{Cont r b}，因此我们可以用我们的续延\hask{k :: b -> r}来运行它。
    \begin{haskell}
        runCont (fk a) k
    \end{haskell}

    总的来说，这个复杂的过程产生了以下实现：
    \begin{haskell}
        instance Monad (Cont r) where
        ma >>= fk = Cont (\k -> runCont ma (\a -> runCont (fk a) k))
        return a = Cont (\k -> k a)
    \end{haskell}
    正如我之前提到的，组合续延不是心脏虚弱者能干的事情。然而，它只需要实现一次——在续延单子的定义中。从那以后，\hask{do}记法会使其余部分相对简单。

    \subsection{Input/Output（输入/输出）}

    \hask{IO}单子的实现嵌入在语言中。基本的I/O原语通过库提供。它们以Kleisli箭头或\hask{IO}对象的形式存在（概念上，Kleisli箭头来自终端对象\hask{()}）。

    例如，以下对象包含从标准输入读取一行的命令：
    \begin{haskell}
        getLine :: IO String
    \end{haskell}
    没有办法从中提取字符串，因为它还不存在；但程序可以通过进一步的Kleisli箭头处理它。

    \hask{IO}单子是终极的拖延症患者：其Kleisli箭头的组合堆积了一个又一个任务，等待由Haskell运行时执行。

    要输出一个字符串并在其后加上换行符，你可以使用这个Kleisli箭头：
    \begin{haskell}
        putStrLn :: String -> IO ()
    \end{haskell}
    结合这两者，你可以构造一个简单的\hask{main}对象：
    \begin{haskell}
        main :: IO ()
        main = getLine >>= putStrLn
    \end{haskell}
    它会回显你输入的字符串。

    \section{Do Notation（do记法）}

    值得重复一遍，单子在编程中的唯一目的是让我们将一个大的Kleisli箭头分解为多个较小的箭头。

    这可以直接通过无点风格使用Kleisli组合\hask{<=<}来完成，或者通过命名中间值并将它们绑定到Kleisli箭头上使用\hask{>>=}来完成。

    一些Kleisli箭头在库中定义，另一些是足够可重用的以保证脱线实现，但在实践中，大多数是作为单次内联lambda表达式实现的。

    这里有一个简单的例子：
    \begin{haskell}
        main :: IO ()
        main =
        getLine >>= \s1 ->
        getLine >>= \s2 ->
        putStrLn ("Hello " ++ s1 ++ " " ++ s2)
    \end{haskell}
    它使用了一个类型为\hask{String->IO ()}的即席Kleisli箭头，由lambda表达式定义：
    \begin{haskell}
        \s1 ->
        getLine >>= \s2 ->
        putStrLn ("Hello " ++ s1 ++ " " ++ s2)
    \end{haskell}
    此lambda表达式的主体进一步通过另一个即席Kleisli箭头分解：
    \begin{haskell}
        \s2 -> putStrLn ("Hello " ++ s1 ++ " " ++ s2)
    \end{haskell}

    这种构造非常常见，因此有一种称为\hask{do}记法的特殊语法，可以减少很多样板代码。例如，上面的代码可以写成：
    \begin{haskell}
        main = do
        s1 <- getLine
        s2 <- getLine
        putStrLn ("Hello " ++ s1 ++ " " ++ s2)
    \end{haskell}
    编译器会自动将其转换为一系列嵌套的lambda表达式。通常，行\hask{s1<-getLine}被读取为：“\hask{s1} \emph{获取}了\hask{getLine}的结果。”

    这里是另一个例子：一个使用列表单子生成从两个列表中取出所有可能的元素对的函数。
    \begin{haskell}
        pairs :: [a] -> [b] -> [(a, b)]
        pairs as bs = do
        a <- as
        b <- bs
        return (a, b)
    \end{haskell}
    注意\hask{do}块中的最后一行必须生成一个单子值——这里通过使用\hask{return}来实现。

    大多数命令式语言缺乏泛型定义单子的抽象能力，因此它们试图硬编码一些更常见的单子。例如，它们实现了异常作为\hask{Either}单子的替代，或者并发任务作为续延单子的替代。一些语言，如C++，引入了模仿Haskell的\hask{do}记法的协程。

    \begin{exercise}
        实现一个适用于任何单子的函数：
        \begin{haskell}
            ap :: Monad m => m (a -> b) -> m a -> m b
        \end{haskell}
        提示：使用\hask{do}记法提取函数和参数。使用\hask{return}返回结果。
    \end{exercise}

    \begin{exercise}
        使用\hask{bind}操作符和lambda重写\hask{pairs}函数。
    \end{exercise}

    \section{Continuation Passing Style（续延传递风格）}

    我之前提到过，\hask{do} 语法糖使得使用续延（continuations）更加自然。续延最重要的应用之一就是将程序转换为 CPS（Continuation Passing Style，续延传递风格）。CPS 转换在编译器构造中非常常见。另一个非常重要的应用是将递归转换为迭代。

    深度递归程序的常见问题是它们可能会耗尽运行时堆栈。函数调用通常会通过在堆栈上推入函数参数、本地变量以及返回地址开始。因此，深度嵌套的递归调用可能会迅速耗尽（通常是固定大小的）运行时堆栈，导致运行时错误。这是为什么命令式语言更喜欢使用循环而非递归，以及为什么大多数程序员在学习递归之前先学习循环的原因。然而，即使在命令式语言中，当涉及到遍历递归数据结构（如链表或树）时，递归算法也是更自然的选择。

    然而，使用循环的问题在于它们需要使用变异（mutation）。通常会有某种计数器或指针在每次循环时进行递增和检查。这就是为什么纯函数式语言（如 Haskell）避免使用变异，并使用递归代替循环的原因。但由于循环更加高效且不会消耗运行时堆栈，编译器会尝试将递归调用转换为循环。在 Haskell 中，所有尾递归函数都会被转换为循环。

    \subsection{Tail recursion and CPS（尾递归与CPS）}

    尾递归（Tail recursion）意味着递归调用发生在函数的最末尾。函数不会对尾调用的结果执行任何附加操作。例如，下面的程序不是尾递归的，因为它需要将 \hask{i} 加到递归调用的结果上：

    \begin{haskell}
        sum1 :: [Int] -> Int
        sum1 [] = 0
        sum1 (i : is) = i + sum1 is
    \end{haskell}

    相反，下面的实现是尾递归的，因为递归调用 \hask{go} 的结果被直接返回而没有进一步的修改：

    \begin{haskell}
        sum2 = go 0
        where go n [] = n
        go n (i : is) = go (n + i) is
    \end{haskell}

    编译器可以轻松地将后者转换为循环。它不会进行递归调用，而是会用 \hask{n + i} 覆盖第一个参数 \hask{n} 的值，用指向列表头部的指针覆盖指向其尾部的指针，然后跳转到函数的开始处。

    然而需要注意的是，这并不意味着 Haskell 编译器不会巧妙地优化第一个实现。它只意味着第二个实现是尾递归的，因此\emph{保证}会被转换为循环。

    实际上，通过执行 CPS 转换，总是可以将递归转换为尾递归。这是因为续延封装了\emph{计算的剩余部分}，因此它总是函数中的最后一个调用。

    要在实践中了解其工作原理，请考虑一个简单的树遍历。我们定义一个存储字符串的树，其中节点和叶子都存储字符串：

    \begin{haskell}
        data Tree = Leaf String
        | Node Tree String Tree
    \end{haskell}

    为了将这些字符串连接起来，我们使用遍历，首先递归进入左子树，然后进入右子树：

    \begin{haskell}
        show :: Tree -> String
        show (Node lft s rgt) =
        let ls = show lft
        rs = show rgt
        in ls ++ s ++ rs
    \end{haskell}

    这显然不是一个尾递归函数，而且如何将其转换为尾递归也并不明显。然而，我们几乎可以机械地使用 continuation monad（续延单子）重写它：

    \begin{haskell}
        showk :: Tree -> Cont r String
        showk (Leaf s) = return s
        showk (Node lft s rgt) = do
        ls <- showk lft
        rs <- showk rgt
        return (ls ++ s ++ rs)
    \end{haskell}

    我们可以使用 trivial continuation \hask{id} 来运行结果：

    \begin{haskell}
        show :: Tree -> String
        show t = runCont (showk t) id
    \end{haskell}

    此实现自动为尾递归。通过展开 do 语法糖，我们可以清楚地看到这一点：

    \begin{haskell}
        showk :: Tree -> (String -> r) -> r
        showk (Leaf s) k = k s
        showk (Node lft s rgt) k =
        showk lft (\ls ->
        showk rgt (\rs ->
        k (ls ++ s ++ rs)))
    \end{haskell}

    让我们分析一下这段代码。函数调用自己，传递左子树 \hask{lft} 以及以下 continuation（续延）：

    \begin{haskell}
        \ls ->
        showk rgt (\rs ->
        k (ls ++ s ++ rs))
    \end{haskell}

    这个 lambda 进一步调用 \hask{showk}，传递右子树 \hask{rgt} 以及另一个 continuation：

    \begin{haskell}
        \rs -> k (ls ++ s ++ rs)
    \end{haskell}

    这个最内层的 lambda 具有访问所有三个字符串（左、中、右）的权限。它们连接后，将结果传递给最外层的 continuation \hask{k}。

    在每种情况下，对 \hask{showk} 的递归调用都是最后的调用，其结果会立即返回。此外，结果的类型是泛型类型 \hask{r}，这本身就保证了我们无法对其执行任何操作。当我们最终运行 \hask{showk} 的结果时，我们将 \hask{id} 传递给它（实例化为 \hask{String} 类型）：

    \begin{haskell}
        show :: Tree -> String
        show t = runCont (showk t) id
    \end{haskell}

    \subsection{Using named functions（使用命名函数）}

    假设我们的编程语言不支持匿名函数。是否有可能用命名函数替代 lambda？当我们讨论伴随函子定理（adjoint functor theorem）时，我们之前已经做过类似的工作。我们注意到由 continuation monad 生成的 lambda 是闭包——它们从环境中捕获一些值。如果我们想用命名函数替换它们，就必须显式地传递环境。

    我们用对名为 \hask{next} 的函数的调用替换第一个 lambda，并以包含三个值 \hask{(s, rgt, k)} 的元组的形式传递必要的环境：

    \begin{haskell}
        showk :: Tree -> (String -> r) -> r
        showk (Leaf s) k = k s
        showk (Node lft s rgt) k =
        showk lft (next (s, rgt, k))
    \end{haskell}

    这三个值分别是树当前节点中的字符串、右子树和外部 continuation。

    函数 \hask{next} 对 \hask{showk} 进行递归调用，传递给它右子树以及名为 \hask{conc} 的 continuation：

    \begin{haskell}
        next :: (String, Tree, String -> r) -> String -> r
        next (s, rgt, k) ls = showk rgt (conc (ls, s, k))
    \end{haskell}

    同样，\hask{conc} 显式捕获包含两个字符串和外部 continuation 的环境。它执行字符串的连接并将结果传递给外部 continuation：

    \begin{haskell}
        conc :: (String, String, String -> r) -> String -> r
        conc (ls, s, k) rs = k (ls ++ s ++ rs)
    \end{haskell}

    最后，我们定义 trivial continuation：

    \begin{haskell}
        done :: String -> String
        done s = s
    \end{haskell}

    用来提取最终结果：

    \begin{haskell}
        show t = showk t done
    \end{haskell}

    \subsection{Defunctionalization（去函数化）}

    CPS（续延传递风格）需要使用高阶函数。如果这是个问题，例如在实现分布式系统时，我们可以始终使用伴随函子定理来去函数化我们的程序。

    第一步是创建所有相关环境的总和，包括我们在 \hask{done} 中使用的空环境：

    \begin{haskell}
        data Kont = Done
        | Next String Tree Kont
        | Conc String String Kont
    \end{haskell}

    请注意，该数据结构可以重新解释为列表或栈。它可以看作是以下求和类型的元素列表：

    \begin{haskell}
        data Sum = Next' String Tree  | Conc' String String
    \end{haskell}

    该列表是我们实现递归算法所需的运行时堆栈的版本。

    因为我们只关心生成字符串作为最终结果，所以我们要近似 \hask{String -> String} 函数类型。此函数类型是定义它的伴随关系的近似余单元（counit）（参见伴随函子定理）：

    \begin{haskell}
        apply :: (Kont, String) -> String
        apply (Done, s) = s
        apply (Next s rgt k, ls) = showk rgt (Conc ls s k)
        apply (Conc ls s k, rs) = apply (k, ls ++ s ++ rs)
    \end{haskell}

    现在可以在不使用高阶函数的情况下实现 \hask{showk} 函数：

    \begin{haskell}
        showk :: Tree -> Kont -> String
        showk (Leaf s) k = apply (k, s)
        showk (Node lft s rgt) k = showk lft (Next s rgt k)
    \end{haskell}

    要提取结果，我们调用它并传递 \hask{Done}：

    \begin{haskell}
        showTree t = showk t Done
    \end{haskell}

    \section{Monads Categorically（范畴论中的Monad）}

    在范畴论中，Monad 首先出现在代数的研究中。特别地，bind 运算符可用于实现非常重要的替换操作。

    \subsection{Substitution（替换）}

    考虑这个简单的表达式类型。它由类型 \hask{x} 参数化，我们可以用它来命名变量：

    \begin{haskell}
        data Ex x = Val Int
        | Var x
        | Plus (Ex x) (Ex x)
        deriving (Functor, Show)
    \end{haskell}

    例如，我们可以构造一个表达式 $(2 + a) + b$：

    \begin{haskell}
        ex :: Ex Char
        ex = Plus (Plus (Val 2) (Var 'a')) (Var 'b')
    \end{haskell}

    我们可以为 \hask{Ex} 实现 \hask{Monad} 实例：

    \begin{haskell}
        instance Monad Ex where
        Val n >>= k = Val n
        Var x >>= k = k x
        Plus e1 e2 >>= k =
        let x = e1 >>= k
        y = e2 >>= k
        in (Plus x y)

        return x = Var x
    \end{haskell}

    现在假设你想通过将变量 $a$ 替换为 $x_1 + 2$，将变量 $b$ 替换为 $x_2$ 来进行替换（为简化起见，我们不考虑其他字母）。此替换由 Kleisli 箭头 \hask{sub} 表示：

    \begin{haskell}
        sub :: Char -> Ex String
        sub 'a' = Plus (Var "x1") (Val 2)
        sub 'b' = Var "x2"
    \end{haskell}

    如你所见，我们甚至能够将用于命名变量的类型从 \hask{Char} 更改为 \hask{String}。

    当我们将此 Kleisli 箭头绑定到 \hask{ex} 时：

    \begin{haskell}
        ex' :: Ex String
        ex' = ex >>= sub
    \end{haskell}

    我们得到的正是与表达式 $(2 + (x_1 + 2)) + x_2$ 对应的树。

    \subsection{Monad as a monoid（Monad作为单子）}

    让我们分析使用 \hask{join} 定义的 Monad：

    \begin{haskell}
        class Functor m => Monad m where
        join :: m (m a) -> m a
        return :: a -> m a
    \end{haskell}

    我们有一个 endofunctor（自函子） \hask{m} 和两个多态函数。

    在范畴论中，定义 Monad 的函子通常用 $T$ 表示（可能是因为 Monad 最初被称为“三元组”）。这两个多态函数成为自然变换。第一个对应于 \hask{join}，将 $T$ 的“平方”（即 $T$ 与自身的复合）映射到 $T$：

    \[ \mu \colon T \circ T \to T \]

    （当然，只有\emph{自}-函子才能以这种方式平方。）

    第二个对应于 \hask{return}，将恒等函子映射到 $T$：

    \[ \eta \colon \text{Id} \to T \]

    与我们之前在单子范畴中定义的单子相比较：

    \begin{align*}
        \mu &\colon m \otimes m \to m \\
        \eta &\colon I \to m
    \end{align*}

    相似性是惊人的。这就是为什么我们经常称自然变换 $\mu$ 为\emph{monadic multiplication}（单子乘法）。但是在哪个范畴中，函子的复合可以视为张量积呢？

    进入 endofunctor 的范畴。该范畴中的对象是 endofunctor，而箭头是自然变换。

    但该范畴还有更多的结构。我们知道，任何两个 endofunctor 都可以复合。如果我们想将 endofunctor 视为对象，该复合如何解释？一种将两个对象结合并产生第三个对象的操作类似于张量积。张量积唯一的条件是它在两个参数中都是函子性的。也就是说，给定一对箭头：

    \begin{align*}
        \alpha &\colon T \to T' \\
        \beta &\colon S \to S'
    \end{align*}

    我们可以将其提升到张量积的映射：

    \[ \alpha \otimes \beta \colon T \otimes S \to T' \otimes S' \]

    在 endofunctor 的范畴中，箭头是自然变换，所以，如果我们将 $\otimes$ 替换为 $\circ$，则提升是复合映射：

    \[ \alpha \circ \beta \colon T \circ T' \to S \circ S' \]

    但这只是自然变换的水平复合（现在你明白为什么它用圆圈表示了）。

    这个 monoidal category（单子范畴）中的单位对象是恒等 endofunctor，并且单位律“在鼻子上”成立，意味着

    \[ \text{Id} \circ T = T = T \circ \text{Id} \]

    我们不需要任何 unitor。我们也不需要任何 associator，因为函子复合是自动关联的。

    单位对象和associator均为恒等态射的monoidal category被称为\index{strict monoidal category}\emph{严格monoidal category}。

    然而需要注意的是，复合不是对称的，因此这不是对称monoidal category。

    总而言之，一个monad是endofunctor的monoidal category中的一个monoid。

    一个monad $(T, \eta, \mu)$由endofunctor范畴中的一个对象组成——即endofunctor $T$；和两个箭头——即自然变换：

    \begin{align*}
        \eta &\colon \text{Id} \to T \\
        \mu &\colon T \circ T \to T
    \end{align*}

    为了成为一个monoid，这些箭头必须满足monoidal laws。以下是单位律（unitor替换为严格等式）：

    \[
        \begin{tikzcd}
            \text{Id} \circ T
            \arrow[rr, "\eta \circ T"]
            \arrow[rrd, "="']
            & & T \circ T
            \arrow[d, "\mu"]
            && T \circ \text{Id}
            \arrow[ll, "T \circ \eta"']
            \arrow[lld, "="]
            \\
            && T
        \end{tikzcd}
    \]

    这是结合律：

    \[
        \begin{tikzcd}
        (T \circ T) \circ T
        \arrow[rr, "="]
        \arrow[d, "\mu \circ T"]
        &&
        T \circ (T \circ T)
        \arrow[d, "T \circ \mu"]
        \\
        T \circ T
        \arrow[dr, "\mu"]
        & & T \circ T
        \arrow[dl, "\mu"']
        \\
        &  T
        \end{tikzcd}
    \]

    我们使用 whiskering notation（掺合记法）来表示 $\mu \circ T$ 和 $T \circ \mu$ 的水平复合。

    这些是使用 $\mu$ 和 $\eta$ 表示的 monad laws。它们可以直接翻译为 \hask{join} 和 \hask{return} 的 laws。它们也等价于使用箭头 $a \to T b$ 构建的 Kleisli 范畴的 laws。

    \section{Free Monads（自由Monad）}

    Monad 允许我们指定可能产生副作用的操作序列。这种序列不仅告诉计算机做什么，还告诉它如何去做。但有时需要更多的灵活性：我们希望将“做什么”与“如何做”分开。自由 Monad 允许我们生成操作序列而无需承诺特定的 Monad 来执行它。这类似于定义自由 Monoid（列表），它让我们推迟选择应用的代数；或者在将其编译为可执行代码之前创建一个抽象语法树（AST）。

    自由构造被定义为遗忘函子的左伴随。因此，我们首先需要定义遗忘 Monad 的含义。由于 Monad 是一个带有额外结构的自函子，我们想遗忘这个结构。我们取一个 Monad $(T, \eta, \mu)$，并仅保留 $T$。但为了将这种映射定义为一个函子，我们首先需要定义 Monad 的范畴。

    \subsection{Category of monads（Monads的范畴）}

    $\mathbf{Mon}(\cat C)$ 范畴中的对象是 Monad $(T, \eta, \mu)$。我们可以定义两个 Monad $(T, \eta, \mu)$ 和 $(T', \eta', \mu')$ 之间的箭头为两个自函子之间的自然变换：

    \[ \lambda \colon T \to T' \]

    然而，由于 Monad 是带有结构的自函子，我们希望这些自然变换能够保留结构。单位的保留意味着以下图表必须交换：

    \[
        \begin{tikzcd}
            &\text{Id}
            \arrow[ld, "\eta"']
            \arrow[rd, "\eta'"]
            \\
            T
            \arrow[rr, "\lambda"]
            && T'
        \end{tikzcd}
    \]

    乘法的保留意味着以下图表必须交换：

    \[
        \begin{tikzcd}
            T \circ T
            \arrow[r, "\lambda \circ \lambda"]
            \arrow[d, "\mu"]
            & T' \circ T'
            \arrow[d, "\mu'"]
            \\
            T
            \arrow[r, "\lambda"]
            & T'
        \end{tikzcd}
    \]

    从另一个角度来看，$\mathbf{Mon}(\cat C)$ 是 monoidal category $([\cat C, \cat C], \circ, \text{Id})$ 中 monoid 的范畴。

    \subsection{Free monad（自由Monad）}

    既然我们有了 Monad 的范畴，我们就可以定义遗忘函子：

    \[ U \colon \mathbf{Mon}(\cat C) \to [\cat C, \cat C] \]

    它将每个三元组 $(T, \eta, \mu)$ 映射为 $T$，并将每个 Monad 态射映射为底层自然变换。

    我们希望自由 Monad 由此遗忘函子的左伴随生成。问题是这个左伴随并不总是存在。通常，这是与规模问题有关：Monad 往往会导致规模爆炸。最终，自由 Monad 对于一些，但不是所有的自函子存在。因此，我们不能通过伴随关系定义自由 Monad。幸运的是，在大多数感兴趣的情况下，自由 Monad 可以定义为代数的固定点。

    这个构造类似于我们如何将自由 Monoid 定义为列表函子的初始代数：

    \begin{haskell}
        data ListF a x = NilF | ConsF a x
    \end{haskell}

    或更一般的形式：

    \[ F_a x = I + a \otimes x \]

    然而这一次，定义 Monad 作为 monoid 的 monoidal category 是 endofunctor 的范畴 $([\cat C, \cat C], \circ, \text{Id})$。在这个范畴中的自由 Monoid 是高阶“列表”函子的初始代数，它将函子映射为函子：

    \[ \Phi_F G = \text{Id} + F \circ G \]

    这里，两个函子的\index{coproduct of functors}coproduct 是按点定义的。在对象上的定义：

    \[ (F + G) a = F a + G a \]

    在箭头上的定义：

    \[ (F + G) f = F f + G f \]

    （我们使用 coproduct 的函子性形成两个态射的 coproduct。我们假设 $\cat C$ 是余笛卡尔的，即所有 coproduct 都存在。）

    初始代数是该运算符的（最小）固定点，或递归方程的解：

    \[ L_F \cong \text{Id} + F \circ L_F \]

    此公式在两个函子之间建立了自然同构。从右到左，$\text{Id} + F \circ L_F \to L_F$，我们有一个从和的映射，相当于一对自然变换：

    \begin{align*}
        \text{Id} \to L_F
        \\
        F \circ L_F \to L_F
    \end{align*}

    当翻译成 Haskell 时，这些变换的组件变成了两个构造函数。我们定义以下由函子 \hask{f} 参数化的递归数据类型：

    \begin{haskell}
        data FreeMonad f a where
        Pure :: a -> FreeMonad f a
        Free :: f (FreeMonad f a) -> FreeMonad f a
    \end{haskell}

    如果我们将函子 \hask{f} 视为值的容器，构造函数 \hask{Free} 会取一个 \hask{(FreeMonad f a)} 的函子并将其存储起来。因此，类型 \hask{FreeMonad f a} 的任意值是一个树，其中每个节点都是分支的函子，每个叶子包含一个类型为 \hask{a} 的值。

    由于此定义是递归的，因此它的 \hask{Functor} 实例也是递归的：

    \begin{haskell}
        instance Functor f => Functor (FreeMonad f) where
        fmap g (Pure a) = Pure (g a)
        fmap g (Free ffa) = Free (fmap (fmap g) ffa)
    \end{haskell}

    这里，外层 \hask{fmap} 使用 \hask{f} 的 \hask{Functor} 实例，而内层的 \hask{(fmap g)} 递归到分支。

    很容易看出 \hask{FreeMonad} 是一个 \hask{Monad}。monadic unit \hask{eta} 只是恒等函子的一个简单封装：

    \begin{haskell}
        eta :: a -> FreeMonad f a
        eta a = Pure a
    \end{haskell}

    monadic multiplication 或 \hask{join} 是递归定义的：

    \begin{haskell}
        mu :: Functor f => FreeMonad f (FreeMonad f a) -> FreeMonad f a
        mu (Pure fa) = fa
        mu (Free ffa) = Free (fmap mu ffa)
    \end{haskell}

    因此，\hask{FreeMonad f} 的 \hask{Monad} 实例为：

    \begin{haskell}
        instance Functor f => Monad (FreeMonad f) where
        return a = eta a
        m >>= k = mu (fmap k m)
    \end{haskell}

    我们也可以直接定义 bind：

    \begin{haskell}
    (Pure a)   >>= k = k a
    (Free ffa) >>= k = Free (fmap (>>= k) ffa)
    \end{haskell}

    自由 Monad 累积 monadic 动作在树状结构中，而不承诺任何特定的评估策略。这个树可以使用代数“解释”。但这次它是 endofunctor 范畴中的代数，因此它的载体是一个 endofunctor $G$，结构映射 $\alpha$ 是自然变换 $\Phi_F G \to G$：

    \[ \alpha \colon \text{Id} + F \circ G \to G\]

    此自然变换作为一个从和的映射，相当于一对自然变换：

    \begin{align*}
        \lambda &\colon \text{Id} \to G
        \\
        \rho &\colon F \circ G \to G
    \end{align*}

    我们可以将其翻译为 Haskell 中的一对多态函数：

    \begin{haskell}
        type MAlg f g a = (a -> g a, f (g a) -> g a)
    \end{haskell}

    由于自由 Monad 是初始代数，因此存在唯一的映射——catamorphism，从它到任何其他代数。回忆一下我们是如何为常规代数定义 catamorphism 的：

    \begin{haskell}
        cata :: Functor f => Algebra f a -> Fix f -> a
        cata alg = alg . fmap (cata alg) . out
    \end{haskell}

    \hask{out} 部分解包固定点的内容。这里我们可以通过对自由 Monad 的两个构造函数进行模式匹配来实现这一点。如果它是一个叶子，我们将 $\lambda$ 应用于它。如果它是一个节点，我们递归处理其内容，并将结果应用于 $\rho$：

    \begin{haskell}
        mcata :: Functor f => MAlg f g a -> FreeMonad f a -> g a
        mcata (l, r) (Pure a) = l a
        mcata (l, r) (Free ffa) =
        r (fmap (mcata (l, r)) ffa)
    \end{haskell}

    许多树状 Monad 实际上是简单函子的自由 Monad。

    \begin{exercise}
        一个（非空）rose tree 定义为：

        \begin{haskell}
            data Rose a = Leaf a | Rose [Rose a]
            deriving Functor
        \end{haskell}

        实现 \hask{Rose a} 和 \hask{FreeMonad [] a} 之间的相互转换。
    \end{exercise}

    \begin{exercise}
        实现二叉树和 \hask{FreeMonad Bin a} 之间的相互转换，其中：

        \begin{haskell}
            data Bin a = Bin a a
        \end{haskell}
    \end{exercise}

    \begin{exercise}
        找到一个函子，其自由 Monad 等价于列表 Monad \hask{[a]}。
    \end{exercise}

    \subsection{Stack calculator example（堆栈计算器示例）}

    作为一个示例，我们来看看一个实现为嵌入式领域特定语言（EDSL）的堆栈计算器。我们将使用自由 Monad 来累积用此语言编写的简单命令。

    命令由函子 \hask{StackF} 定义。将参数 \hask{k} 视为 continuation。

    \begin{haskell}
        data StackF k  = Push Int k
        | Top (Int -> k)
        | Pop k
        | Add k
        deriving Functor
    \end{haskell}

    例如，\hask{Push} 旨在将整数压入堆栈，然后调用 continuation \hask{k}。

    此函子的自由 Monad 可以被视为一棵树，大多数分支只有一个子节点，因此形成列表。例外是 \hask{Top} 节点，它有许多子节点，每个子节点对应于一个 \hask{Int} 值。

    这是该函子的自由 Monad：

    \begin{haskell}
        type FreeStack = FreeMonad StackF
    \end{haskell}

    为了创建特定领域的程序，我们将定义一些辅助函数。有一个泛型函数将一个函子的值提升为自由 Monad：

    \begin{haskell}
        liftF :: (Functor f) => f r -> FreeMonad f r
        liftF fr = Free (fmap (Pure) fr)
    \end{haskell}

    我们还需要一系列“智能构造函数”，它们是自由 Monad 的 Kleisli 箭头：

    \begin{haskell}
        push :: Int -> FreeStack ()
        push n = liftF (Push n ())

        pop :: FreeStack ()
        pop = liftF (Pop ())

        top :: FreeStack Int
        top = liftF (Top id)

        add :: FreeStack ()
        add = liftF (Add ())
    \end{haskell}

    由于自由 Monad 是 Monad，因此我们可以方便地使用 \hask{do} 语法结合 Kleisli 箭头。例如，这里有一个玩具程序，它将两个数字相加并返回它们的和：

    \begin{haskell}
        calc :: FreeStack Int
        calc = do
        push 3
        push 4
        add
        x <- top
        pop
        return x
    \end{haskell}

    为了执行该程序，我们需要定义一个代数，其载体是一个 endofunctor。由于我们要实现一个基于堆栈的计算器，我们将使用状态函子的一个版本。其状态是一个整数列表。状态函子定义为一个函数类型；在这里，它是一个接受列表并返回新列表与类型参数 \hask{k} 的函数：

    \begin{haskell}
        data StackAction k = St ([Int] -> ([Int], k))
        deriving Functor
    \end{haskell}

    要运行该动作，我们将函数应用于堆栈：

    \begin{haskell}
        runAction :: StackAction k -> [Int] -> ([Int], k)
    \end{haskell}

    我们将代数定义为自由 Monad 的两个构造函数（\hask{Pure} 和 \hask{Free}）对应的一对多态函数：

    \begin{haskell}
        runAlg :: MAlg StackF StackAction a
        runAlg = (stop, go)
    \end{haskell}

    第一个函数终止程序的执行并返回一个值：

    \begin{haskell}
        stop :: a -> StackAction a
        stop a = St (\xs -> (xs, a))
    \end{haskell}

    第二个函数对命令的类型进行模式匹配。每个命令携带一个 continuation。这个 continuation 必须与一个（可能已修改的）堆栈一起运行。每个命令以不同的方式修改堆栈：

    \begin{haskell}
        go :: StackF (StackAction k) -> StackAction k
        go (Pop k)    = St (\ns -> runAction k (tail ns))
        go (Top ik)   = St (\ns -> runAction (ik (head ns)) ns)
        go (Push n k) = St (\ns -> runAction k (n: ns))
        go (Add k)    = St (\ns -> runAction k
        ((head ns + head (tail ns)): tail (tail ns)))
    \end{haskell}

    例如，\hask{Pop} 丢弃堆栈的顶部。 \hask{Top} 从堆栈顶部获取一个整数，并用它选择要执行的分支。它通过将函数 \hask{ik} 应用于该整数来实现这一点。 \hask{Add} 将堆栈顶部的两个数字相加并将结果压入堆栈。

    注意，我们定义的代数不涉及递归。从操作中分离递归是自由 Monad 方法的优势之一。相反，递归被一次编码在 catamorphism 中。

    这是一个可以用来运行我们的玩具程序的函数：

    \begin{haskell}
        run :: FreeMonad StackF k -> ([Int], k)
        run prog = runAction (mcata runAlg prog) []
    \end{haskell}

    显然，使用部分函数 \hask{head} 和 \hask{tail} 使我们的解释器变得脆弱。格式不正确的程序会导致运行时错误。更健壮的实现将使用允许错误传播的代数。

    使用自由 Monad 的另一个优势是相同的程序可以使用不同的代数进行解释。

    \begin{exercise}
        实现一个“漂亮打印机”来显示使用我们的自由 Monad 构建的程序。提示：实现使用 \hask{Const} 函子作为载体的代数：

        \begin{haskell}
            showAlg :: MAlg StackF (Const String) a
        \end{haskell}
    \end{exercise}

\section{Monoidal Functors}

We've seen several examples of monoidal cateogries. Such categories are equipped with some kind of binary operation, e.g., a cartesian product, a sum, composition (in the category of endofunctors), etc. They also have a special object that serves as the unit with respect to that binary operation. Unit and associativity laws are satisfied either on the nose (in strict monoidal categories) or up to isomorphism.

Every time we have more than one instance of some structure, we may ask ourselves the question: is there a whole category of such things? In this case: do monoidal categories form their own category? For this to work we would have to define arrows between monoidal categories.

A \emph{monoidal functor} $F$ from a monoidal category $(\mathcal{C}, \otimes, i)$ to another monoidal category $(\mathcal{D}, \oplus, j)$ maps tensor product to tensor product and unit to unit---all up to isomorphism:
\begin{align*}
F a \oplus F b &\cong F (a \otimes b) \\
j &\cong F i
\end{align*}
Here, on the left-hand side we have the tensor product and the unit in the target category, and on the right their counterparts in the source category.

If the two monoidal categories in question are not strict, that is the unit and associativity laws are satisfied only up to isomorphism, there are additional coherency conditions that ensure that unitors are mapped to unitors and associators are mapped to associators.

The category of monoidal categories with monoidal functors as arrows is called $\mathbf{MonCat}$. In fact it's a 2-category, since one can define structure-preserving natural transformations between monoidal functors.

\subsection{Lax monoidal functors}

One of the perks of monoidal categories is that they allow us to define monoids. You can easily convince yourself that monoidal functors map monoids to monoids. It turns out that you don't need the full power of monoidal functors to accomplish that. Let's consider what the minimal requirements are  for a functor to map monoids to monoids.

Let's start with a monoid $(m, \mu, \eta)$ in the monoidal category $(\mathcal{C}, \otimes, i)$. Consider a functor $F$ that maps $m$ to $F m$. We want $F m$ to be a monoid in the target monoidal category $(\mathcal{D}, \oplus, j)$. For that we need to find two mappings:
\begin{align*}
\eta' &\colon j \to F m \\
 \mu' &\colon F m \oplus F m \to F m
\end{align*}
satisfying monoidal laws.

Since $m$ is a monoid, we do have at our disposal the liftings of the original mappings:
\begin{align*}
 F \eta &\colon F i \to F m \\
 F \mu &\colon F (m \otimes m) \to F m
\end{align*}

What we are missing, in order to implement $\eta'$ and $\mu'$, are two additional arrows:
\begin{align*}
j &\to F i\\
 F m \oplus F m &\to F (m \otimes m)
 \end{align*}
A monoidal functor would provide such arrows. However, for what we're trying it accomplish, we don't need these arrows to be invertible.

A \emph{lax monoidal functor} is a functor equipped with a morphism $\phi_i$ and a natural transformation $\phi_{ab}$:
\begin{align*}
\phi_i &\colon j \to F i \\
\phi_{a b} &\colon F a \oplus F b \to F (a \otimes b)
\end{align*}
satisfying the appropriate unitality and associativity conditions.

Such a functor maps a monoid $(m, \mu, \eta)$ to a monoid $(F m, \mu', \eta')$ with:
\begin{align*}
\eta' &= F \eta \circ \phi_i \\
\mu' &= F \mu \circ \phi_{a b}
\end{align*}

The simplest example of a lax monoidal functor is an endofunctor that preserves the usual cartesian product. We can define it in Haskell as a typeclass:

\begin{haskell}
class Monoidal f where
  unit  :: f ()
  (>*<) :: f a -> f b -> f (a, b)
\end{haskell}
Corresponding to $\phi_{a b}$ we have an infix operator which, according to Haskell conventions, is written in its curried form.

\begin{exercise}
Implement the \hask{Monoidal} instance for the list functor.
\end{exercise}

\subsection{Functorial strength}

There is another way a functor may interact with monoidal structure, one that hides in plain sight when we do programming. We take it for granted that functions have access to the environment. Such functions are called closures.

For instance, here's a function that captures a variable \hask{a} from the environment and pairs it with its argument:
\begin{haskell}
\x -> (a, x)
\end{haskell}
This definition makes no sense in isolation, but it does when the environment contains the variable \hask{a}, e.g.,
\begin{haskell}
pairWith :: Int -> (String -> (Int, String))
pairWith a = \x -> (a, x)
\end{haskell}
The function returned by calling \hask{pairWith 5} ``closes over'' the 5 from its environment.

Now consider the following modification, which returns a singleton list that contains the closure:
\begin{haskell}
pairWith' :: Int -> [String -> (Int, String)]
pairWith' a = [\x -> (a, x)]
\end{haskell}
As a programmer you'd be very surprised if this didn't work. But what we do here is highly nontrivial: we are smuggling the environment \emph{under} the list functor. According to our model of lambda calculus, a closure is a morphism from the product of the environment and the function argument. Here the lambda, which is really a function of \hask{(Int, String)}, is defined inside a list functor, but it captures the value \hask{a} that is defined \emph{outside} the list.

The property that lets us smuggle the environment under a functor is called \index{strength, functorial}\emph{functorial strength} or \emph{tensorial strength} and can be implemented in Haskell as:
\begin{haskell}
strength :: Functor f => (e, f a) -> f (e, a)
strength (e, as) = fmap (e, ) as
\end{haskell}
The notation \hask{(e, )} is called a \index{tuple section}\emph{tuple section} and is equivalent to the partial application of the pair constructor: \hask{(,) e}.

In category theory, strength for an endofunctor $F$ is defined as a natural transformation that smuggles a tensor product into a functor:
\[ \sigma \colon a \otimes F(b) \to F (a \otimes b) \]
There are some additional conditions which ensure that it works nicely with the unitors and the associator of the monoidal category in question.

The fact that we were able to implement \hask{strength} for an arbitrary functor means that, in Haskell, every functor is strong. This is the reason why we don't have to worry about accessing the environment from inside a functor.

Even more importantly, every monad in Haskell is strong by virtue of being a functor. This is also why every monad is automatically \hask{Monoidal}.
\begin{haskell}
instance Monad m => Monoidal m where
  unit = return ()
  ma >*< mb = do
    a <- ma
    b <- mb
    return (a, b)
\end{haskell}
If you desugar this code to use monadic bind and lambdas, you'll notice that the final \hask{return} needs access to both \hask{a} and \hask{b}, which are defined in outer environments. This would be impossible without a monad being strong.

In category theory, though, not every endofunctor in a monoidal category is strong. For now, the magic incantation is that the category we're working with is self-enriched, and every endofunctor defined in Haskell is enriched. We'll come back to it when we talk about enriched categories. In Haskell, strength boils down to the fact that we can always \hask{fmap} a partially applied pair constructor \hask{(a, )}.

\subsection{Applicative functors}

In programming, the idea of applicative functors arose from the following question: A functor lets us lift a function of one variable. How can we lift a function of two or more variables?

By analogy with \hask{fmap}, we'd like to have a function:
\begin{haskell}
liftA2 :: (a -> b -> c) -> f a -> f b -> f c
\end{haskell}

A function of two arguments---here, in its curried form---is a function of one argument returning a function. So, assuming that \hask{f} is a functor, we can \hask{fmap} the first argument of \hask{liftA2}, which has the type:
\begin{haskell}
a -> (b -> c)
\end{haskell}
over the second argument \hask{(f a)} to get:
\begin{haskell}
f (b -> c)
\end{haskell}
The problem is, we don't know how to apply \hask{f (b -> c)} to the remaining argument \hask{(f b)}.

The class of functors that let us do that is called \hask{Applicative}. It turns out that, once we know how to lift a two-argument function, we can lift functions of any number of arguments, except zero. A zero-argument function is just a value, so lifting it means implementing a function:
\begin{haskell}
pure :: a -> f a
\end{haskell}
Here's the Haskell definition:
\begin{haskell}
class Functor f => Applicative f where
    pure  :: a -> f a
    (<*>) :: f (a -> b) -> f a -> f b
\end{haskell}
The application of a functorful of functions to a functorful of arguments is defined as an infix operator \hask{<*>} that is customarily called ``splat.''

There is also an infix version of \hask{fmap}:
\begin{haskell}
(<$>) :: Functor f => (a -> b) -> f a -> f b
\end{haskell}
which can be used in this terse implementation of \hask{liftA2}:
\begin{haskell}
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
liftA2 g as bs = g <$> as <*> bs
\end{haskell}
Both operators bind to the left, which makes this syntax mimic regular function application.

An applicative functor must also satisfy a set of laws:
\begin{haskell}
pure id <*> v = v                            -- Identity
pure f <*> pure x = pure (f x)               -- Homomorphism
u <*> pure y = pure ($ y) <*> u              -- Interchange
pure (.) <*> u <*> v <*> w = u <*> (v <*> w) -- Composition
\end{haskell}

\begin{exercise}
Implement $\emph{\hask{liftA3}}$, a function that lifts a 3-argument function using an applicative functor.
\end{exercise}

\subsection{Closed functors}
If you squint at the definition of the splat operator:
\begin{haskell}
(<*>) :: f (a -> b) -> (f a -> f b)
\end{haskell}
you may see it as mapping function objects to function objects.

This becomes clearer if you consider a functor between two categories, both of them closed. You may start with a function object $b^a$ in the source category and apply the functor $F$ to it:
\[ F (b^a) \]
Alternatively, you may map the two objects $a$ and $b$ and construct a function object between them in the target category:
\[ (F b)^{F a} \]
If we demand that the two ways be isomorphic, we get a definition of a strict \emph{closed functor}. But, as was the case with monoidal functors, we are more interested in the lax version, which is equipped with a one-way natural transformation:
\[ F (b^a) \to (F b)^{F a} \]
If $F$ is an endofunctor, this translates directly into the definition of the splat operator.

The full definition of a lax closed functor includes the mapping of the monoidal unit and some coherence conditions. All said, an applicative functor is a lax closed functor.

In a closed cartesian category, the exponential is related to the cartesian product through the currying adjunction. It's no surprise then, that in such a category lax monoidal and lax closed (applicative) endofunctors are the same.

We can easily express this in Haskell:
\begin{haskell}
instance (Functor f, Monoidal f) => Applicative f where
  pure a = fmap (const a) unit
  fs <*> as = fmap apply (fs >*< as)
\end{haskell}
where \hask{const} is a function that ignores its second argument:
\begin{haskell}
const :: a -> b -> a
const a b = a
\end{haskell}
and \hask{apply} is the uncurried function application:
\begin{haskell}
apply :: (a -> b, a) -> b
apply (f, a) = f a
\end{haskell}
And the other way around we have:
\begin{haskell}
instance Applicative f => Monoidal f where
  unit = pure ()
  as >*< bs = (,) <$> as <*> bs
\end{haskell}
In the latter, we used the pair constructor \hask{(,)} as a two-argument function.

\subsection{Monads and applicatives}

Since in a cartesian closed category every monad\footnote{Again, the correct incantation is ``every enriched monad''} is lax monoidal, it is automatically applicative. We can show it directly by implementing \hask{ap}, which has the same type signature as the splat operator:
\begin{haskell}
ap :: (Monad m) => m (a -> b) -> m a -> m b
ap fs as = do
    f <- fs
    a <- as
    return (f a)
\end{haskell}

This connection is expressed in the Haskell definition of a \hask{Monad} by having \hask{Applicative} as its superclass:
\begin{haskell}
class Applicative m => Monad m where
    (>>=)       :: forall a b. m a -> (a -> m b) -> m b
    return      :: a -> m a
    return      = pure
\end{haskell}
Notice the default implementation of \hask{return} as \hask{pure}.

The converse is not true: not every \hask{Applicative} is a \hask{Monad}. The standard counterexample is the \hask{Applicative} instance for a list functor that uses zipping:
\begin{haskell}
instance Applicative [] where
  pure = repeat
  fs <*> as = zipWith apply fs as
\end{haskell}
Of course, the list functor is also a monad, so there is another \hask{Applicative} instance based on that. Its splat operator applies every function to every argument.

In programming, monad is more powerful than applicative. That's because monadic code lets you examine the contents of a monadic value and branch depending on it. This is true even for the \hask{IO} monad which otherwise provides no means of extracting the value. In this example we are branching on the contents of an \hask{IO} object:
\begin{haskell}
main :: IO ()
main = do
  s <- getLine
  if s == "yes"
  then putStrLn "Thank you!"
  else putStrLn "Next time."
\end{haskell}
Of course, the inspection of the value is postponed until the runtime interpreter of \hask{IO} gets hold of this code.

Applicative composition using the splat operator doesn't allow for one part of the computation to inspect the result of the other. This a limitation that can be turned into an advantage. The absence of dependencies makes it possible to run the computations in parallel.  Haskell's parallel libraries use applicative programming extensively.

On the other hand, monads let us use the very convenient \hask{do} syntax, which is arguably more readable than the applicative syntax. Fortunately, there is a language extension \hask{ApplicativeDo}, which instructs the compiler to selectively use applicative constructs in interpreting \hask{do} blocks, whenever there are no dependencies.

\begin{exercise}
Verify \hask{Applicative} laws for the zip instance of the list functor.
\end{exercise}




\end{document}