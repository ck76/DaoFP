\documentclass[DaoFP]{subfiles}
\begin{document}
 \setcounter{chapter}{17}

 \chapter{Tambara 模块 (Tambara Modules)}

 在编程中，范畴论的一个不太知名的领域突然获得了新的关注：Tambara 模块在 profunctor optics 中得到了新的应用。它们为 optics 的组合问题提供了一个巧妙的解决方案。我们已经看到，对于透镜 (lenses) 来说，getter 可以通过函数组合来很好地组合，但 setter 的组合则涉及一些复杂操作。存在的表示法帮助不大。而使用 profunctor 表示法，组合变得非常简单。

 这种情况类似于图形编程中组合几何变换的问题。例如，如果你尝试组合绕两个不同轴的旋转，新轴和角度的公式会非常复杂。但如果将旋转表示为矩阵，你可以使用矩阵乘法；或者将其表示为四元数 (quaternions)，你可以使用四元数乘法。profunctor 表示法让你可以使用简单的函数组合来组合 optics。

 \section{Tannakian 重建 (Tannakian Reconstruction)}

 \subsection{幺半群与其表示 (Monoids and their Representations)}

 表示论本身就是一门科学。在这里，我们将从范畴论的角度来探讨它。我们将考虑幺半群 (monoids) 而不是群 (groups)。幺半群可以定义为单对象范畴 $\cat M$ 中的一个特殊对象。如果我们将其对象称为 $*$，那么同态集 $\cat M( *, *)$ 包含了我们所需的所有信息。

 在幺半群中称为“乘积”的操作在这里被形态组合取代。根据范畴的定律，它是结合的，并且具有单位元——即身份形态。

 在这个意义上，每个单对象范畴自动是一个幺半群，并且所有幺半群都可以变为单对象范畴。

 例如，可以将全体整数的幺半群（加法）看作一个只有一个抽象对象 $*$ 的范畴，并且每个整数对应一个形态。要组合两个这样的形态，你只需将它们的数值相加，如下图所示：
 \[
  \begin{tikzcd}
   *
   \arrow[r, bend left, "2"]
   \arrow[rr, bend right, "5"']
   & *
   \arrow[r, bend left, "3"]
   & *
  \end{tikzcd}
 \]
 与零对应的形态自动是身份形态。

 我们可以将幺半群\emph{表示}为集合的变换。这样的表示是由函子 $F \colon \cat M \to \Set$ 给出的。它将单个对象 $*$ 映射到某个集合 $S$，并将同态集 $\cat M(*, *)$ 映射到一组 $S \to S$ 的函数。根据函子定律，它将身份形态映射为身份函数，并将组合映射为组合，因此它保持了幺半群的结构。

 如果函子是完全忠实的 (fully faithful)，那么其像包含与幺半群相同的信息，且没有其他信息。然而，通常情况下，函子会“作弊”。同态集 $\Set (S, S)$ 可能包含一些不在 $\cat M(*, *)$ 像中的函数；而且 $\cat M$ 中的多个形态可能映射到同一个函数。

 在极端情况下，整个同态集 $\cat M(*, *)$ 可能被映射到身份函数 $id_S$。所以，仅仅通过查看集合 $S$——即函子 $F$ 下的 $*$ 的像——我们无法重建原始的幺半群。

 尽管如此，如果我们可以同时查看给定幺半群的所有表示，我们可能还有机会。这些表示形成一个范畴——函子范畴 $[\cat M, \Set]$，也称为 $\cat M$ 上的余预层范畴 (co-presheaf category)。这个范畴中的箭头是自然变换 (natural transformations)。

 由于源范畴 $\cat M$ 只包含一个对象，自然性条件变得特别简单。自然变换 $\alpha \colon F \to G$ 只有一个分量，即函数 $\alpha \colon F * \to G *$。给定一个形态 $m \colon * \to *$，自然性方块如下：
 \[
  \begin{tikzcd}
   F *
   \arrow[r, "\alpha"]
   \arrow[d, "F m"]
   & G *
   \arrow[d, "G m"]
   \\
   F *
   \arrow[r, "\alpha"]
   & G *
  \end{tikzcd}
 \]
 这是在两个集合上作用的三个函数之间的关系：
 \[
  \begin{tikzcd}
   F *
   \arrow[loop, "F m"']
   \arrow[rr, bend right, "\alpha"']
   && G *
   \arrow[loop, "G m"']
  \end{tikzcd}
 \]
 自然性条件告诉我们：
 \[ G m \circ \alpha = \alpha \circ F m \]

 换句话说，如果你选择集合 $F *$ 中的任意元素 $x$，你可以使用 $\alpha$ 将它映射到 $G *$，然后应用与 $m$ 对应的变换 $G m$；或者你可以先应用变换 $F m$，然后使用 $\alpha$ 映射结果。结果必须相同。

 这样的函数被称为 \index{等变函数 (equivariant function)}\emph{等变函数}。我们通常称 $F m$ 为幺半群在集合 $F *$ 上的 \index{幺半群作用 (monoid action)}\emph{作用}。等变函数通过前置组合或后置组合将一个集合上的作用连接到另一个集合上的对应作用。

 \subsection{幺半群的 Tannakian 重建 (Tannakian Reconstruction of a Monoid)}

 我们需要多少信息才能从幺半群的表示中重建一个幺半群？仅仅查看集合显然不够，因为任何幺半群都可以在任意集合上表示。但如果我们包括这些集合之间的结构保持函数，我们可能有机会。

 给定一个函子 $F \colon \cat M \to \Set$，考虑所有函数 $F* \to F*$ 的集合，即同态集 $\Set(F *, F *)$。至少其中一些函数是幺半群的作用。这些函数的形式为 $F m$，其中 $m$ 是 $\cat M$ 中的一个箭头。不过，必须注意，这个同态集中可能有许多不对应于作用的函数。

 现在让我们看看另一个集合 $G *$，它是某个其他函子 $G$ 的像。在它的同态集 $\Set(G *, G *)$ 中，我们会发现（包括其他的）形式为 $G m$ 的对应作用。一个等变函数，即 $[\cat M, \Set]$ 中的自然变换，将连接任何两个相关的作用 $F m$ 和 $G m$。

 现在，想象创建一个巨大的元组，其中每个元素是从所有函子 $F\colon \cat M \to \Set$ 的同态集 $\Set (F *, F *)$ 中选择的一个函数。我们只对那些彼此连接的元组感兴趣。这里我的意思是：如果我们选择 $g \in  \Set (G*, G *)$ 和  $h \in  \Set (H*,  H*)$，并且在函子 $G$ 和 $H$ 之间存在一个自然变换（等变函数）$\alpha$，我们希望这两个函数是相关的：
 \[ \alpha \circ g = h \circ \alpha \]
 或者，图示如下：
 \[
  \begin{tikzcd}
   G *
   \arrow[loop, "g"']
   \arrow[rr, bend right, "\alpha"']
   && H *
   \arrow[loop, "h"']
  \end{tikzcd}
 \]
 注意，这种相关性也适用于不形式为 $g = G m$ 和 $h=H m$ 的 $g$ 和 $h$ 对。

 这样的元组正是端的元素：
 \[ \int_F \Set(F *, F *) \]
 其楔条件 (wedge condition) 提供了我们所寻找的约束。

 \[
  \begin{tikzcd}
   & \int_F \Set (F *, F *)
   \arrow[dl, "\pi_G"']
   \arrow[dr, "\pi_H"]
   \\
   \Set(G *, G *)
   \arrow[dr, "\alpha \circ -"']
   && \Set (H *, H *)
   \arrow[dl, "- \circ \alpha"]
   \\
   & \Set (G *, H *)
  \end{tikzcd}
 \]
 这里 $\alpha$ 是函子范畴 $[\cat M, \Set ]$ 中的一个形态：
 \[ \alpha \colon G \to H \]
 这个自然变换只有一个分量，我们也称它为 $\alpha$。它是两个表示之间的等变函数。

 这里有一些细节。端下的 profunctor 由下式给出：
 \[ P \langle G, H \rangle = \Set (G *, H *) \]
 它是以下形式的函子：
 \[ P \colon [\cat M, \Set]^{op} \times [\cat M, \Set] \to \Set \]
 考虑它在 $[\cat M, \Set]$ 中形态对上的作用。给定一对自然变换：
 \begin{align*}
  \alpha &\colon G' \to G \\
  \beta &\colon H \to H'
 \end{align*}
 它们的提升是一个函数：
 \[ P\langle \alpha, \beta \rangle \colon  P\langle G, H \rangle \to P\langle G', H' \rangle\]
 代入我们对 $P$ 的定义，我们有：
 \[ P\langle \alpha, \beta \rangle \colon  \Set ( G*, H*)  \to \Set (G'*, H'*)\]
 我们通过与 $\alpha$ 的前置组合和与 $\beta$ 的后置组合来得到这个函数（这些函数是两个自然变换 $\alpha$ 和 $\beta$ 的唯一分量）：
 \[ P \langle \alpha, \beta \rangle = \beta \circ - \circ \alpha \]
 即，给定一个函数 $f \in \Set(G*, H*)$，我们生成一个函数 $\beta \circ f \circ \alpha \in \Set(G' *, H' *)$。

 在楔条件中，如果我们选择 $g$ 为 $\Set (G*, G*)$ 的元素，$h$ 为 $\Set (H*, H*)$ 的元素，我们就重现了我们的条件：
 \[ \alpha \circ g = h \circ \alpha \]

 Tannakian 重建定理在这种情况下告诉我们：
 \[ \int_F \Set(F *, F *) \cong \cat M (*, *) \]
 换句话说，我们可以从幺半群的表示中恢复幺半群。我们将在更一般的陈述中看到这个定理的证明。

 \subsection{Cayley 定理 (Cayley's Theorem)}

 在群论中，Cayley 定理指出每个群都同构于一个置换群的子群。一个 \index{群 (group)}\emph{群} 只是一个幺半群，其中每个元素都有一个逆元素。置换是将一个集合映射到它自身的双射函数。它们\emph{置换}集合中的元素。

 在范畴论中，Cayley 定理几乎内置于幺半群及其表示的定义中。

 在单对象解释和幺半群的更传统的元素集解释之间建立联系非常容易。我们通过构造函子 $F \colon \cat M \to \Set$ 来实现这一点，该函子将 $*$ 映射到一个特殊集合 $S$，该集合等于同态集：$S = \cat M(*, *)$。这个集合的元素与 $\cat M$ 中的形态相对应。我们将 $F$ 在形态上的作用定义为后置组合：
 \[ (F m) n = m \circ n \]
 这里 $m$ 是 $\cat M$ 中的一个形态，而 $n$ 是集合 $S$ 的一个元素，恰好也是 $\cat M$ 中的一个形态。

 我们可以将这种特定表示作为 $\Set$ 中幺半群的一种替代定义。我们所需要的只是实现单位元和乘法：
 \begin{align*}
  \eta &\colon 1 \to S \\
  \mu &\colon S \times S \to S
 \end{align*}
 单位元选择与 $\cat M(*, *)$ 中的 $id_*$ 对应的 $S$ 元素。两个元素 $m$ 和 $n$ 的乘法由与 $m \circ n$ 对应的元素给出。

 同时，我们可以将 $S$ 视为 $F \colon \cat M \to \Set$ 的像，在这种情况下，形成幺半群表示的是 $S \to S$ 的函数。这就是 Cayley 定理的本质：每个幺半群都可以用一组自函子表示。

 在编程中，Cayley 定理的最佳应用示例是高效实现列表反转。回想一下反转的简单递归实现：
 \begin{haskell}
  reverse :: [a] -> [a]
  reverse [] = []
  reverse (a : as) = reverse as ++ [a]
 \end{haskell}
 它将列表分为头和尾，反转尾部，然后将头组成的单元素列表追加到结果中。问题是每次追加都必须遍历不断增长的列表，导致 $O(N^2)$ 的性能。

 然而，请记住，列表是一个（自由）幺半群：
 \begin{haskell}
  instance Monoid [a] where
  mempty = []
  mappend as bs = as ++ bs
 \end{haskell}
 我们可以使用 Cayley 定理将这个幺半群表示为列表上的函数：
 \begin{haskell}
  type DList a = [a] -> [a]
 \end{haskell}
 为了表示一个列表，我们将其转换为一个函数。它是一个函数（闭包），将这个列表 \hask{as} 追加到其参数 \hask{xs} 中：
 \begin{haskell}
  rep :: [a] -> DList a
  rep as = \xs -> as ++ xs
 \end{haskell}
 这种表示称为 \index{差异列表 (difference list)}\emph{差异列表}。

 要将一个函数还原为列表，只需将其应用于一个空列表：
 \begin{haskell}
  unRep :: DList a -> [a]
  unRep f = f []
 \end{haskell}
 很容易验证，空列表的表示是一个恒等函数，而两个列表的连接表示是表示的组合：
 \begin{haskell}
  rep [] = id
  rep (xs ++ ys) = rep xs . rep ys
 \end{haskell}
 所以这正是列表幺半群的 Cayley 表示。

 现在我们可以翻译反转算法以生成这个新表示：
 \begin{haskell}
  rev :: [a] -> DList a
  rev [] = rep []
  rev (a : as) = rev as . rep [a]
 \end{haskell}
 然后将其还原为列表：
 \begin{haskell}
  fastReverse :: [a] -> [a]
  fastReverse = unRep . rev
 \end{haskell}
 乍一看，这似乎没有做太多，除了在我们的递归算法之上添加了一个转换层。除了新的算法具有 $O(N)$ 而不是 $O(N^2)$ 的性能。要看清这一点，考虑反转一个简单列表 \hask{[1, 2, 3]}。函数 \hask{rev} 将这个列表变成了一个函数组合：
 \begin{haskell}
  rep [3] . rep [2] . rep [1]
 \end{haskell}
 它以线性时间完成这一操作。函数 \hask{unRep} 从空列表开始执行这个组合。但请注意，每个 \hask{rep} 都会将其参数\emph{前置}到累积结果中。特别是，最后的 \hask{rep [3]} 执行了：
 \begin{haskell}
 [3] ++ [2, 1]
 \end{haskell}
 与追加不同，前置是一个常数时间操作，因此整个算法的时间复杂度为 $O(N)$。

 另一种看待它的方式是，认识到 \hask{rev} 按照列表元素的顺序从头部开始排列操作队列。但函数队列按先进先出 (FIFO) 顺序执行。

 由于 Haskell 的惰性，使用 \hask{foldl} 的列表反转具有类似的性能：
 \begin{haskell}
  reverse = foldl (\as a -> a : as) []
 \end{haskell}
 这是因为 \hask{foldl} 在返回结果之前，从左到右遍历列表，累积函数（闭包）。然后根据需要按 FIFO 顺序执行它们。

 \subsection{Tannakian 重建的证明 (Proof of Tannakian Reconstruction)}

 幺半群重建是一个更一般定理的特例，其中我们使用了一个常规范畴而不是单对象范畴。与幺半群的情况一样，我们将重建同态集，只是这次它是两个对象之间的常规同态集。我们将证明公式：
 \[ \int_{F \colon [\cat C, \Set]} \Set (F a, F b) \cong \cat C(a, b) \]
 技巧是使用 Yoneda 引理来表示 $F$ 的作用：
 \[ F a \cong [\cat C, \Set] ( \cat C (a ,-), F) \]
 同样地，我们也可以表示 $F b$。我们得到：
 \[ \int_{F \colon [\cat C, \Set]} \Set ([\cat C, \Set] ( \cat C (a ,-), F), [\cat C, \Set] ( \cat C (b ,-), F)) \]
 注意，这里的两个自然变换集是 $[\cat C, \Set]$ 中的同态集。

 回想一下 Yoneda 引理的推论，它适用于任何范畴 $\cat A$：
 \[ [\cat A, \Set] (\cat A (x, -), \cat A (y, -)) \cong \cat A (y, x) \]
 我们可以用端 (end) 来表示它：
 \[ \int_{z \colon \cat C} \Set (\cat A (x, z), \cat A (y, z)) \cong \cat A (y, x) \]
 特别地，我们可以用函子范畴 $[\cat C, \Set]$ 替换 $\cat A$。我们得到：
 \[ \int_{F \colon [\cat C, \Set]} \Set ([\cat C, \Set] ( \cat C (a ,-), F), [\cat C, \Set] ( \cat C (b ,-), F)) \cong [\cat C, \Set](\cat C (b ,-), \cat C (a ,-))\]
 然后我们可以再次应用 Yoneda 引理到右侧，得到：
 \[ \cat C (a, b) \]
 这正是我们所寻找的结果。

 重要的是要意识到函子范畴的结构如何通过楔条件进入端。它通过自然变换实现。每当我们在两个函子 $\alpha \colon G \to H$ 之间有一个自然变换时，以下图表必须交换：
 \[
  \begin{tikzcd}
   & \int_F \Set (F a, F b)
   \arrow[dl, "\pi_G"']
   \arrow[dr, "\pi_H"]
   \\
   \Set(G a, G b)
   \arrow[dr, "{\Set(id, \alpha)}"']
   && \Set (H a, H b)
   \arrow[dl, "{\Set (\alpha, id)}"]
   \\
   & \Set (G a, H b)
  \end{tikzcd}
 \]

 要对 Tannakian 重建有一些直观理解，你可以回忆起 $\Set$ 值函子可以解释为与证据相关的子集。函子 $F \colon \cat C \to \Set$（一个余预层）定义了一个小范畴 $\cat C$ 的对象子集。我们说某个对象 $a$ 属于这个子集当且仅当 $F a$ 是非空的。然后 $F a$ 的每个元素都可以解释为该子集的证据。

 但是，除非所讨论的范畴是离散的，并不是所有子集都对应于余预层。特别是，每当存在一个箭头 $f \colon a \to b$ 时，也存在一个函数 $F f \colon F a \to F b$。根据我们的解释，这样的函数将 $a$ 属于 $F$ 定义的子集的每个证据映射为 $b$ 属于该子集的证据。因此，余预层定义了与范畴结构兼容的证据相关子集。

 让我们以同样的精神重新解释 Tannakian 重建。
 \[ \int_{F \colon [\cat C, \Set]} \Set (F a, F b) \cong \cat C(a, b) \]
 左侧的元素是一个证据，表明对于与 $\cat C$ 的结构兼容的每个子集，如果 $a$ 属于该子集，那么 $b$ 也属于该子集。这只有在存在从 $a$ 到 $b$ 的箭头时才有可能。

 \subsection{Haskell 中的 Tannakian 重建 (Tannakian Reconstruction in Haskell)}

 我们可以立即将这个结果翻译到 Haskell 中。我们用 \hask{forall} 替换端。左侧变为：
 \begin{haskell}
  forall f. Functor f => f a -> f b
 \end{haskell}
 右侧则是函数类型 \hask{a->b}。

 我们之前已经见过多态函数：它们是为所有类型或某些类型类定义的函数。这里我们有一个为所有函子定义的函数。它说：给我一个装有 \hask{a} 的函子，我将产生一个装有 \hask{b} 的函子——无论你使用什么函子。唯一可以实现它的方法（使用参数多态性）是这个函数秘密地捕获了一个类型为 \hask{a->b} 的函数，并使用 \hask{fmap} 进行应用。

 事实上，同构的一方向就是这样：捕获一个函数并在参数上 \hask{fmap} 它：
 \begin{haskell}
  toRep :: (a -> b) -> (forall f. Functor f => f a -> f b)
  toRep g fa = fmap g fa
 \end{haskell}
 另一个方向使用了 Yoneda 技巧：
 \begin{haskell}
  fromRep :: (forall f. Functor f => f a -> f b) -> (a -> b)
  fromRep g a = unId (g (Id a))
 \end{haskell}
 其中恒等函子 (identity functor) 定义如下：
 \begin{haskell}
  data Id a = Id a

  unId :: Id a -> a
  unId (Id a) = a

  instance Functor Id where
  fmap g (Id a) = Id (g a)
 \end{haskell}

 这种重建看起来可能显得微不足道且无意义。为什么有人会想要将函数类型 \hask{a->b} 替换为一个复杂得多的类型：
 \begin{haskell}
  type Getter a b = forall f. Functor f => f a -> f b
 \end{haskell}
 不过，有趣的是，将 \hask{a->b} 视为所有 optics 的前身是很有意义的。它是一个透镜，聚焦于 $a$ 中的 $b$ 部分。它告诉我们 $a$ 包含了足够的信息，以某种形式或其他形式构造 $b$。它是一个“getter”或“访问器 (accessor)”。

 显然，函数是可以组合的。不过有趣的是，函子表示也可以组合，并且它们通过简单的函数组合来组合，如下例所示：
 \begin{haskell}
  boolToStrGetter :: Getter Bool String
  boolToStrGetter = toRep (show) . toRep (bool 0 1)
 \end{haskell}
 其他 optics 的组合就不那么简单了，但它们的函子（和 profunctor）表示组合却非常简单。

 \subsection{带伴随的 Tannakian 重建 (Tannakian Reconstruction with Adjunction)}

 广义的 Tannakian 重建技巧是在某个专业函子范畴 $\cat T$ 上首先应用遗忘函子，然后定义端。我们假设在两个函子范畴 $\cat T$ 和 $[\cat C, \Set]$ 之间存在自由/遗忘伴随 $F \dashv U$：
 \[ \cat T (F Q, P) \cong  [\cat C, \Set] ( Q, U P )\]
 其中 $Q$ 是 $[\cat C, \Set]$ 中的一个函子，$P$ 是 $\cat T$ 中的一个函子。

 我们用于 Tannakian 重建的起点是以下端：
 \[ \int_{P \colon \cat T} \Set \big((U P) a, (U P) s\big) \]

 顺便说一下，参数化为对象 $a$ 的映射 $\cat T \to \Set$ 由以下公式给出：
 \[ P \mapsto (U P) a \]
 有时称为\index{纤维函子 (fiber functor)}\emph{纤维函子}，因此端公式可以解释为两个纤维函子之间的自然变换集。概念上，纤维函子描述了一个对象的“微分邻域”。它将函子映射到集合，但更重要的是，它将自然变换映射到函数。这些函数探测对象所处的环境。特别是 $\cat T$ 中的自然变换参与定义端的楔条件。（在微积分中，层的茎 (stalks) 扮演着非常类似的角色。）

 像以前一样，我们首先应用 Yoneda 引理，得到：
 \[ \int_{P \colon \cat T} \Set \Big([\cat C, \Set] \big( \cat C (a ,-), U P\big), [\cat C, \Set] \big( \cat C (s ,-), U P\big)\Big) \]
 现在我们可以使用伴随：
 \[ \int_{P \colon \cat T} \Set \Big(\cat T \big( F \cat C (a ,-), P\big), \cat T \big( F \cat C (s ,-), P\big)\Big) \]
 我们最终得到了两个函子范畴 $\cat T$ 中自然变换之间的映射。我们可以使用 Yoneda 引理的推论来进行积分，得到：
 \[ \cat T\big( F \cat C (s ,-), F \cat C (a ,-) \big) \]
 我们可以再次应用伴随：
 \[ \Set \big( \cat C (s ,-), (U\circ F) \cat C (a ,-) \big) \]
 并再次应用 Yoneda 引理：
 \[ \big( (U\circ F) \cat C (a ,-) \big) s \]
 最后的观察是，伴随函子的复合 $U \circ F$ 是函子范畴中的一个幺半群。我们将这个幺半群称为 $\Phi$。结果是以下等式，它将作为 profunctor optics 的基础：
 \[ \int_{P \colon \cat T} \Set \big((U P) a, (U P) s\big) \cong \big( \Phi \cat C (a ,-) \big) s \]
 右侧是幺半群 $\Phi = U \circ F$ 对可表示函子 $\cat C (a, -)$ 的作用，然后在 $s$ 处求值。

 将其与早期的 Tannakian 重建公式进行比较，特别是如果我们将其重写为以下形式：
 \[ \int_{F \colon [\cat C, \Set]} \Set (F a, F s) \cong \cat C(a, -) s\]

 请记住，在 optics 的推导中，我们将 $a$ 和 $s$ 替换为 $\cat C^{op} \times \cat C$ 中的对象对 $\langle a, b \rangle$ 和 $\langle s, t \rangle$。在这种情况下，我们的函子将变为 profunctor。
\end{document}



\section{Profunctor Lenses}

Our goal is to find a functor representation for optics. We've seen before that, for instance, type-changing lenses can be seen as hom-sets in the $\mathbf{Lens}$ category. The objects in $\mathbf{Lens}$ are pairs of objects from some category $\cat C$, and a hom-set from one such pair $\langle s, t \rangle$ to another  $\langle a, b \rangle$ is given by the coend formula:
\[ \mathcal{L}\langle s, t\rangle \langle a, b \rangle = \int^{c} \mathcal{C}(s, c \times a) \times  \mathcal{C}(c \times b, t) \]
Notice that the pair of hom-sets in this formula can be seen as a single hom-set in the product category $\cat C^{op} \times \cat C$:
\[  \mathcal{L}\langle s, t\rangle \langle a, b \rangle =  \int^{c} (\cat C^{op} \times \cat C )(c \bullet \langle a, b \rangle, \langle s, t \rangle)  \]
where we define the action of $c$ on a pair $\langle a, b \rangle$ as:
\[ c \bullet \langle a, b \rangle = \langle c \times a, c \times b \rangle \]
This is a shorthand notation for the diagonal part of a more general action of $\cat C^{op} \times \cat C$ on itself given by:
 \[ \langle c, c' \rangle \bullet \langle a, b \rangle = \langle c \times a, c' \times b \rangle \]


This suggests that, to represent such optics, we should be looking at co-presheaves on the category $\cat C^{op} \times \cat C$, that is, we should be considering profunctor representations. 

\subsection{Iso}
As a quick check of this idea, let's apply our reconstruction formula to the simple case of $\cat T = [\cat C^{op} \times \cat C, \Set]$ with no additional structure. In that case we don't need to use the forgetful functors, or the monad $\Phi$, and we just get the straightforward application of Tannakian reconstruction:
\[  \mathcal{O}\langle s, t\rangle \langle a, b \rangle =\int_{P \colon \cat T} \Set \big(P \langle a, b\rangle, P \langle s, t\rangle \big) \cong \big( (\cat C^{op} \times \cat C) (\langle a, b\rangle ,-) \big) \langle s, t\rangle \]
The right hand side evaluates to:
\[ (\cat C^{op} \times \cat C) (\langle a, b\rangle , \langle s, t\rangle) = \cat C (s, a) \times \cat C (b, t) \]

This optic is known in Haskell as \hask{Iso} (or an adapter):
\begin{haskell}
type Iso s t a b = (s -> a, b -> t)
\end{haskell}
and it, indeed, has a profunctor representation corresponding to the following end:
\begin{haskell}
type IsoP s t a b = forall p. Profunctor p => p a b -> p s t
\end{haskell}

Given a pair of functions it's easy to construct this profunctor-polymorphic function:
\begin{haskell}
toIsoP :: (s -> a, b -> t) -> IsoP s t a b
toIsoP (f, g) = dimap f g
\end{haskell}
This is simply saying that any profunctor can be used to lift a pair of functions. 

Conversely, we may ask the question: How can a single polymorphic function map the set $P \langle a, b \rangle$ to the set $P \langle s, t \rangle$ for \emph{every} profunctor imaginable? The only thing this function knows about the profunctor is that it can lift a pair of functions. Therefore it must be a closure that either contains or is able to produce a pair of functions \hask{(s -> a, b -> t)}. 

\begin{exercise}
Implement the function:
\begin{haskell}
fromIsoP :: IsoP s t a b -> (s -> a, b -> t)
\end{haskell}
Hint: Use the fact that a pair of identity functions can be used to construct the following profunctor:
\begin{haskell}
data Adapter a b s t = Ad (s -> a, b -> t)
\end{haskell}
\end{exercise}

\subsection{Profunctors and lenses}

Let's try to apply the same logic to lenses. We have to find a class of profunctors to plug into our profunctor representation. Let's assume that the forgetful functor $U$ only forgets additional structure but doesn't change the sets, so the set $P \langle a, b \rangle$ is the same as the set $(U P) \langle a, b \rangle$. 

Let's start with the existential representation. We have at our disposal an object $c$ and a pair of functions:
\[  \langle f, g \rangle \colon \cat C(s, c \times a) \times \cat C(c \times b, t) \]
We want to build a profunctor representation, so we have to be able to map the set $P \langle a, b \rangle$ to the set $P \langle s, t \rangle$. We could get $P \langle s, t \rangle$ by lifting these two functions, but only if start from $P \langle c \times a, c \times b \rangle$. Indeed:
\[ P \langle f, g \rangle \colon P \langle c \times a, c \times b \rangle \to P \langle s, t \rangle \]
What we are missing is the mapping:
\[ P \langle a, b \rangle \to P \langle c \times a, c \times b \rangle \]
And this is exactly the additional structure we shall demand from our profunctor class. 

\subsection{Tambara module}

A profunctor $P$ equipped with the family of transformations:
\[ \alpha_{\langle a, b\rangle, c} \colon P \langle a, b \rangle \to P \langle c \times a, c \times b \rangle \]
is called a \emph{Tambara module}. 

We want this family to be natural in $a$ and $b$, but what should we demand from $c$? The problem with $c$ is that it appears twice, once in the contravariant, and once in the covariant position. So, if we want to interact nicely with arrows like $h \colon c \to c'$, we have to modify the naturality condition. We may consider a more general profunctor $P \langle c' \times a, c \times b \rangle$ and treat $\alpha$ as producing its diagonal elements, ones in which $c'$ is the same as $c$. 

A transformation $\alpha$ between diagonal parts of two profunctors $P$ and $Q$ is called a \index{dinatural transformation}\emph{dinatural transformation} (\emph{di}-agonally natural) if the following diagram commutes for any $f \colon c \to c'$:

\[
 \begin{tikzcd}
 & P \langle c', c \rangle
 \arrow[dl, "{P \langle f, c \rangle}"']
 \arrow[dr, "{P \langle c', f \rangle}"]
 \\
 P \langle c, c \rangle 
  \arrow[d, "\alpha_c"']
 && P \langle c', c' \rangle
 \arrow[d, "\alpha_{c'}"]
 \\
 Q \langle c, c \rangle
   \arrow[dr, "{P \langle c, f \rangle}"']
 &&  Q \langle c', c' \rangle
 \arrow[dl,"{P \langle f, c \rangle}"]
\\
&Q \langle c, c' \rangle
 \end{tikzcd}
\]
(I used the common shorthand $P \langle f, c \rangle$, reminiscent of whiskering, for $P \langle f, id_c \rangle$.)

In our case, the dinaturality condition simplifies to:
\[
 \begin{tikzcd}
 & P \langle a, b \rangle
 \arrow[dl, "{\alpha_{\langle a, b \rangle, c}}"']
 \arrow[dr, "{\alpha_{\langle a, b \rangle, c'}}"]
 \\
 P \langle c \times a, c \times b \rangle
   \arrow[dr, "{P \langle c \times a, f \times b \rangle}"']
 &&  P \langle c' \times a, c'  \times b\rangle
 \arrow[dl,"{P \langle f \times b, c \times b \rangle}"]
\\
&P \langle c \times a, c' \times b \rangle
 \end{tikzcd}
\]
(Here, again $P \langle f \times b, c \times b \rangle$ stands for $P \langle f \times id_b, id_{c \times b} \rangle$.)

There is one more consistency condition on Tambara modules: they must preserve the monoidal structure. The action of multiplying by $c$ makes sense in a cartesian category: we have to have a product for any pair of objects, and we want to have the terminal object to serve as the unit of multiplication. Tambara modules have to respect unit and preserve multiplication. For the unit (terminal object), we impose the following condition:
\[ \alpha_{\langle a, b \rangle, 1} = id _{P \langle a, b \rangle}\]
For multiplication, we have:
\[ \alpha_{\langle a, b \rangle, c' \times c} \cong  \alpha_{\langle c \times a, c \times b \rangle, c'} \circ  \alpha_{\langle a, b \rangle, c}\]
or, pictorially:
\[
 \begin{tikzcd}
 P \langle a, b \rangle
 \arrow[rr, "{\alpha_{\langle a, b \rangle, c' \times c } }"]
 \arrow[rdd, "{ \alpha_{\langle a, b \rangle, c}}"']
 &&
 P \langle c' \times c \times a, c' \times c \times b \rangle
 \\
 \\
 & P \langle c \times a, c \times b \rangle
  \arrow[ruu, "{\alpha_{\langle c \times a, c \times b \rangle, c'}}"']
\end{tikzcd}
\]
(Notice that the product is associative up to isomorphism, so there is a hidden associator in this diagram.)

Since we want Tambara modules to form a category, we have to define morphisms between them. These are natural transformations that preserve the additional structure. Let's say we have a natural transformation $\rho$ between two Tambara modules $\rho \colon (P, \alpha) \to (Q, \beta) $. We can either apply $\alpha$ and then $\rho$, or do $\rho$ first and then  $\beta$. We want the result to be the same:
\[
 \begin{tikzcd}
  P \langle a, b \rangle
 \arrow[d, "{ \rho_{\langle a, b \rangle}}"']
 \arrow[r, "{ \alpha_{\langle a, b \rangle, c}}"]
  &  P \langle c \times a, c \times b \rangle
  \arrow[d, "{ \rho_{\langle c \times a, c \times b \rangle}}"]
\\
   Q \langle a, b \rangle
 \arrow[r, "{ \beta_{\langle a, b \rangle, c}}"]
 &  Q \langle c \times a, c \times b \rangle
 \end{tikzcd}
\]
Keep in mind that the structure of the Tambara category is encoded in these natural transformations. They will determine, through the wedge condition, the shape of the ends that enter the definition of profunctor lenses.

\subsection{Profunctor lenses}

Now that we have some intuition about how Tambara modules are related to lenses, let's go back to our main formula:
\[  \mathcal{L}\langle s, t\rangle \langle a, b \rangle =\int_{P \colon \cat T} \Set \big((U P) \langle a, b\rangle, (U P) \langle s, t\rangle \big) \cong \big( \Phi (\cat C^{op} \times \cat C) (\langle a, b\rangle ,-) \big) \langle s, t\rangle \]
This time we're taking the end over the Tambara category. The only missing part is the monad $\Phi = U \circ F$ or the functor $F$ that freely generates Tambara modules.

It turns out that, instead of guessing the monad, it's easier to guess the comonad. There is a comonad in the category of profunctors that takes a profunctor $P$ and produces another profunctor $\Theta P$. Here's the formula:
\[(\Theta P) \langle a, b \rangle = \int_c P \langle c \times a, c \times b \rangle \]
You can check that this is indeed a comonad by implementing $\varepsilon$ and $\delta$ (\hask{extract} and \hask{duplicate}). For instance, $\varepsilon$ maps $\Theta P \to P$ using the projection $\pi_1$ for the terminal object (the unit of cartesian product).

What's interesting about this comonad is that its coalgebras are Tambara modules. Again, these are coalgebras that map profunctors to profunctors. They are natural transformations $P \to \Theta P$. We can write such a natural transformation as an element of the end:
\[\int_{a, b} \Set \big (P \langle a, b \rangle, (\Theta P) \langle a, b \rangle \big) = \int_{a, b} \int_c \Set \big( P\langle a, b \rangle , P \langle c \times a, c \times b \rangle \big) \]
I used the continuity of the hom-functor to pull out the end over $c$. The resulting end encodes a set of natural (dinatural in $c$) transformations that define a Tambara module:
\[ \alpha_{\langle a, b\rangle, c} \colon P \langle a, b \rangle \to P \langle c \times a, c \times b \rangle \]
In fact, these coalgebras are \emph{comonad} coalgebras, that is they are compatible with the comonad $\Theta$. In other words, Tambara modules form the Eilenberg-Moore category of coalgebras for the comonad $\Theta$.

The left adjoint to $\Theta$ is a monad $\Phi$ given by the formula:
\[(\Phi P)  \langle s, t \rangle = \int^{u, v, c} (\cat C^{op} \times \cat C) \big(c \bullet \langle u, v\rangle , \langle s, t \rangle\big) \times P \langle u, v \rangle \]
where I used the shorthand notation:
\[ (\cat C^{op} \times \cat C) \big(c \bullet \langle u, v\rangle , \langle s, t \rangle\big) = \cat C(s, c \times u) \times \cat C(c \times v, t) \]

This adjunction can be easily verified using some end/coend manipulations: The mapping out of $\Phi P$ to some profunctor $Q$ can be written as an end. The coends in $\Phi$ can then be taken out using co-continuity of the hom-functor. Finally, applying the ninja-Yoneda lemma produces the mapping into $\Theta Q$. We get:
\[ [(\cat C^{op} \times \cat C, \Set] (P \Phi, Q) \cong [(\cat C^{op} \times \cat C, \Set] (P, \Theta Q) \]

Replacing $Q$ with $P$ we immediately see that the set of algebras for $\Phi$ is isomorphic to the set of coalgebras for $\Theta$. In fact they are monad algebras for $\Phi$. This means that the Eilenberg-Moore category for the monad $\Phi$ is the same as the Tambara category.

Recall that the Eilenberg-Moore construction factorizes a monad into a free/forgetful adjunction. This is exactly the adjunction we were looking for when deriving the formula for profunctor optics. 

What remains is to evaluate the action of $\Phi$ on the representable functor:
\[ \big( \Phi (\cat C^{op} \times \cat C) (\langle a, b\rangle ,-) \big) \langle s, t\rangle = \int^{u, v, c} (\cat C^{op} \times \cat C) \big(c \bullet \langle u, v\rangle , \langle s, t \rangle \big) \times  (\cat C^{op} \times \cat C) \big(\langle a, b\rangle , \langle u, v\rangle \big)\]
Applying the co-Yoneda lemma, we get:
\[ \int^c (\cat C^{op} \times \cat C) \big(c \bullet \langle a, b\rangle , \langle s, t \rangle\big) = \int^c \cat C(s, c \times a) \times \cat C (c \times b, t)\]
which is exactly the existential representation of the lens.

\subsection{Profunctor lenses in Haskell}

To define profunctor representation in Haskell we introduce a class of profunctors that are Tambara modules with respect to cartesian product (we'll see more general Tambara modules later). In the Haskell library this class is called \hask{Strong}. It also appears in the literature as \hask{Cartesian}:
\begin{haskell}
class Profunctor p => Cartesian p where
  alpha :: p a b -> p (c, a) (c, b)
\end{haskell}
The polymorphic function \hask{alpha} has all the relevant naturality properties guaranteed by parametric polymorphism. 

The profunctor lens is just a type synonym for a function type that is polymorphic in \hask{Cartesian} profunctors:
\begin{haskell}
type LensP s t a b = forall p. Cartesian p => p a b -> p s t
\end{haskell}

The easiest way to implement such a function is to start from the existential representation of a lens and apply \hask{alpha} followed by \hask{dimap} to the profunctor argument:
\begin{haskell}
toLensP :: LensE s t a b -> LensP s t a b
toLensP (LensE from to) = dimap from to . alpha
\end{haskell}

Because profunctor lenses are just functions, we can compose them as such:
\begin{haskell}
lens1 :: LensP s t x y 
-- p s t -> p x y
lens2 :: LensP x y a b 
-- p x y -> p a b
lens3 :: LensP s t a b 
-- p s t -> p a b
lens3 = lens2 . lens1
\end{haskell}

The converse mapping from a profunctor representation to the set/get representation of the lens is also possible. For that we need to guess the profunctor that we can feed into \hask{LensP}. It turns out that the get/set representation of the lens is such a profunctor, when we fix the pair of types \hask{a} and \hask{b}. We define:
\begin{haskell}
data FlipLens a b s t = FlipLens (s -> a) (s -> b -> t)
\end{haskell}
It's easy to show that it's indeed a profunctor:
\begin{haskell}
instance Profunctor (FlipLens a b) where
  dimap f g (FlipLens get set) = FlipLens (get . f) (fmap g . set . f)
\end{haskell}
Not only that---it is also a \hask{Cartesian} profunctor:
\begin{haskell}
instance Cartesian (FlipLens a b) where
  alpha(FlipLens get set) = FlipLens get' set'
    where get' = get . snd
          set' = \(x, s) b -> (x, set s b)
\end{haskell}
We can now initialize \hask{FlipLens} with a trivial pair of a getter and a setter and feed it to our profunctor representation:
\begin{haskell}
fromLensP :: LensP s t a b -> (s -> a, s -> b -> t)
fromLensP pp = (get', set')
  where FlipLens get' set' = pp (FlipLens id (\s b -> b))
\end{haskell}

\section{General Optics}
Tambara modules were originally defined for an arbitrary monoidal category\footnote{In fact, Tambara modules were originally defined for a category enriched over vector spaces} with a tensor product $\otimes$ and a unit object $I$. Their structure maps have the form:
\[ \alpha_{\langle a, b\rangle, c} \colon P \langle a, b \rangle \to P \langle c \otimes a, c \otimes b \rangle \]
You can easily convince yourself that all coherency laws translate directly to this case, and the derivation of profunctor optics works without a change.

\subsection{Prisms}

From the programming point of view there are two obvious monoidal structures to explore: the product and the sum. We've seen that the product gives rise to lenses. The sum, or the coproduct, gives rise to prisms. 

We get the existential representation simply by replacing the product by the sum in the definition of a lens:
\[ \mathcal{P}\langle s, t\rangle \langle a, b \rangle = \int^{c} \mathcal{C}(s, c + a) \times  \mathcal{C}(c + b, t) \]
To simplify this, notice that the mapping out of a sum is equivalent to the product of mappings:
\[ \int^{c} \mathcal{C}(s, c + a) \times  \mathcal{C}(c + b, t) \cong  \int^{c} \mathcal{C}(s, c + a) \times  \mathcal{C}(c, t) \times  \mathcal{C}(b, t) \]
Using the co-Yoneda lemma, we can get rid of the coend to get:
\[ \mathcal{C}(s, t + a) \times  \mathcal{C}(b, t) \]

In Haskell, this defines a pair of functions:
\begin{haskell}
match :: s -> Either t a
build :: b -> t
\end{haskell}

To understand this, let's first translate the existential form of the prism:
\begin{haskell}
data Prism s t a b where
  Prism :: (s -> Either c a) -> (Either c b -> t) -> Prism s t a b
\end{haskell}
Here \hask{s} either contains the focus \hask{a} or the residue \hask{c}. Conversely, \hask{t} can be built either from the new focus \hask{b}, or from the residue \hask{c}. 

This logic is reflected in the conversion functions:
\begin{haskell}
toMatch :: Prism s t a b -> (s -> Either t a)
toMatch (Prism from to) s =
  case from s of
    Left  c -> Left (to (Left c))
    Right a -> Right a
\end{haskell}

\begin{haskell}
toBuild :: Prism s t a b -> (b -> t)
toBuild (Prism from to) b = to (Right b)
\end{haskell}

\begin{haskell}
toPrism :: (s -> Either t a) -> (b -> t) -> Prism s t a b
toPrism match build = Prism from to
  where
    from = match
    to (Left  c) = c
    to (Right b) = build b
\end{haskell}

The profunctor representation of the prism is almost identical to that of the lens, except for swapping the product for the sum. 

The class of Tambara modules for the sum type is called \hask{Choice} in the Haskell library, or \hask{Cocartesian} in the literature:
\begin{haskell}
class Profunctor p => Cocartesian p where
  alpha' :: p a b -> p (Either c a) (Either c b)
\end{haskell}
The profunctor representation is a polymorphic function type:
\begin{haskell}
type PrismP s t a b = forall p. Cocartesian p => p a b -> p s t
\end{haskell}

The conversion from the existential prism is virtually identical to that of the lens:
\begin{haskell}
toPrismP :: Prism s t a b -> PrismP s t a b
toPrismP (Prism from to) = dimap from to . alpha'
\end{haskell}

Again, profunctor prisms compose using function composition.
\subsection{Traversals}
A traversal is a type of optic that focuses on multiple foci at once. Imagine, for instance, that you have a tree that can have zero or more leaves of type \hask{a}. A traversal should be able to get you a list of those nodes. It should also let you replace these nodes with a new list. And here's the problem: the length of the list that delivers the replacements must match the number of nodes, otherwise bad things happen. 

A type-safe implementation of a traversal would require us to keep track of the sizes of lists. In other words, it would require dependent types.

In Haskell, a (non-type-safe) traversal is often written as:
\begin{haskell}
type Traversal s t a b = s -> ([b] -> t, [a])
\end{haskell}
with the understanding that the sizes of the two lists are determined by \hask{s} and must be the same. 

When translating traversals to categorical language, we'll express this condition using a sum over the sizes of the list. A counted list of size $n$ is an $n$-tuple, or an element of $a^n$, so we can write:
\[ \mathbf{Tr} \langle s, t\rangle \langle a, b \rangle = \Set \big( s, \sum_n (\Set (b^n, t) \times a^n) \big) \]
We interpret a traversal as a function that, given a source $s$ produces an existential type that is hiding an $n$. It says that there exists an $n$ and a pair consisting of a function $b^n \to t$ and an $n$-tuple $a^n$. 

The existential form of a traversal must take into account the fact that the residues for different $n$'s will have, in principle, different types. For instance, you can decompose a tree into an n-tuple of leaves $a^n$ and the residue $c_n$ with $n$ holes. So the correct existential representation for a traversal must involve a coend over all sequences $c_n$ that are indexed by natural numbers:
\[ \mathbf{Tr} \langle s, t\rangle \langle a, b \rangle = \int^{c_n} \cat C (s, \sum_m c_m \times a^m) \times \cat C (\sum_k c_k \times b^k, t) \]
The sums here are coproducts in $\cat C$.

One way to look at sequences $c_n$ is to interpret them as fibrations. For instance, in $\Set$ we would start with a set $C$ and a projection $p \colon C \to \mathbb N$, where $\mathbb N$ is a set of natural numbers. Similarly $a^n$ could be interpreted as a fibration of the free monoid on $a$ (the set of lists of $a$'s) with the projection that extracts the length of the list.

Or we can look at $c_n$'s as mappings from the set of natural numbers to $\cat C$. In fact, we can treat natural numbers as a discrete category $\cat N$, in which case $c_n$'s are functors $\cat N \to \cat C$.

\[ \mathbf{Tr} \langle s, t\rangle \langle a, b \rangle = \int^{c \colon [\cat N, \cat C]} \cat C (s, \sum_m c_m \times a^m) \times \cat C (\sum_k c_k \times b^k, t) \]

To show the equivalence of the two representations, we first rewrite the mapping out of a sum as a product of mappings:
\[\int^{c \colon [\cat N, \cat C]} \cat C (s, \sum_m c_m \times a^m) \times \prod_k \cat C (c_k \times b^k, t) \]
and then use the currying adjunction:
\[\int^{c \colon [\cat N, \cat C]} \cat C (s, \sum_m c_m \times a^m) \times \prod_k \cat C (c_k,  [b^k, t]) \]
Here, $[b^k, t]$ is the internal hom, which is an alternative notation for the exponential object $t^{b^k}$.

The next step is to recognize that a product in this formula represents a set of natural transformations in $[\cat N, \cat C]$. Indeed, we could write it as an end:
 \[ \prod_k \cat C (c_k,  [b^k, t] \cong \int_{k : \cat N} C (c_k,  [b^k, t]) \]
This is because an end over a discrete category is just a product. Alternatively, we could write it as a hom-set in the functor category:
\[ [\cat N, \cat C](c_{-}, [b^{-}, t]) \]
with placeholders replacing the arguments to the two functors in question:
\[ k \mapsto c_k \]
\[ k \mapsto [b^k, t] \]

We can now use the co-Yoneda lemma in the functor category $[\cat N, \cat C]$:
\[\int^{c \colon [\cat N, \cat C]} \cat C (s, \sum_m c_m \times a^m) \times  [\cat N, \cat C]\big(c_{-}, [b^{-}, t]\big) \cong \cat C(s, \sum_m [b^m, t] \times a^m)\]
This result is more general than our original formula, but it turns into it when restricted to the category of sets.

To derive a profunctor representation for traversals, we should look more closely at the kind of transformations that are involved. We define the action of a functor $c \colon [\cat N, \cat C]$ on $a$ as:
\[ c \bullet a = \sum_m c_m \times a^m \]
These actions can be composed by expanding the formula using distributivity laws:
\[ c \bullet (c' \bullet a) = \sum_m c_m \times (\sum_n c'_n \times a^n)^m \]
If the target category is $\Set$, this is equivalent to the following Day convolution (for non-$\Set$ categories, one could use the enriched version of the Day convolution):
\[ (c \star c')_k = \int^{m, n} \cat N (m + n, k) \times c_m \times c'_n \]
This gives monoidal structure to the category $[\cat N, \cat C]$. 

The existential representation of traversals can be written is terms of the action of this monoidal category on $\cat C$:
\[ \mathbf{Tr} \langle s, t\rangle \langle a, b \rangle = \int^{c \colon [\cat N, \cat C]} \cat C (s, c \bullet a) \times \cat C (c \bullet b, t) \]

To derive the profunctor representation of traversals, we have to generalize Tambara modules to the action of a monoidal category:
\[ \alpha_{\langle a, b\rangle, c} \colon P \langle a, b \rangle \to P \langle c \bullet a, c \bullet b \rangle \]
It turns out that the original derivation of profunctor optics still works for these generalized Tambara modules, and traversals can be written as polymorphic functions:
\[  \mathbf{Tr}\langle s, t \rangle \langle a, b \rangle 
 =\int_{P \colon \cat T} \Set \big((U P) \langle a, b\rangle, (U P) \langle s, t\rangle \big) \]
where the end is taken over a generalized Tambara module.

\section{Mixed Optics}

Whenever we have an action of a monoidal category $\cat M$ on $\cat C$ we can define the corresponding optic. A category with such an action is called an \index{actegory}\emph{actegory}. We can go even further by considering two separate actions. Suppose that $\cat M$ can act on both $\cat C$ and $\cat D$. We'll use the same notation for both actions:
\[ \bullet \colon \cat M \times \cat C \to \cat C \]
\[ \bullet \colon \cat M \times \cat D \to \cat D \]
We can then define the \index{mixed optics}\emph{mixed optics} as:
\[ \mathcal{O} \langle s, t \rangle \langle a, b \rangle = \int^{m \colon \cat M} \cat C(s, m \bullet a) \times \cat D(m \bullet b, t) \]
These mixed optics have profunctor representations in terms of profunctors:
\[ P \colon \cat C ^{op} \times \cat D \to \Set \]
and the corresponding Tambara modules that use two separate actions:
\[ \alpha_{\langle a, b\rangle, m} \colon P \langle a, b \rangle \to P \langle m \bullet a, m \bullet b \rangle \]
with $a$ an object of $\cat C$, $b$ and object of $\cat D$, and $m$ and object of $\cat M$.

\begin{exercise}
What are the mixed optics for the action of the cartesian product when one of the categories is the terminal category? What if the first category is $\cat C^{op} \times \cat C$ and the second is terminal?
\end{exercise}

\end{document}